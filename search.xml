<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[webpack快速上手]]></title>
    <url>%2Fposts%2Ff2244df3%2F</url>
    <content type="text"><![CDATA[基于webpack4.+(webpack4以下不适用)=&gt;推荐根据官方文档进行使用 – 按照本教程,需要将webpack删除干净,否则可能与旧版本冲突 目录结构 12345678910111213141516|-dist |-...|-node_modules |-...|-src |-css |-... |-js |-... |-images |-... |-index.html |-main.js =&gt; 项目的js入口文件|-package.lock.json|-package.json|-webpack.config.js 必须步骤 初始化项目 1$ npm init -y (全部默认yes) 安装webpack 12$ npm install --save-dev webpack$ npm install --save-dev webpack@&lt;version&gt; 安装webpack-cli(4.+必须安装) 1$ npm install --save-dev webpack-cli webpack.config.js 12345678910const path = require('path');module.exports = &#123; entry: './src/main.js', //入口文件 output: &#123; //打包到dist/bundle.js filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125;; package.json=&gt;指向webpack.config.js 12345"scripts": &#123; "start": "webpack --config webpack.config.js", "dev": "webpack --mode development", "build": "webpack --mode production"&#125; 运行 1$ npm run start|dev|build =&gt;"start|dev|build"来源于package.json中的配置 在index.html中引入bundle.js即可在浏览器运行 1&lt;script src="../dist/bundle.js"&gt;&lt;/script&gt; 常见包安装jquery 安装1$ npm i jquery -S bootstrap安装1$ npm i bootstrap@3 webpack-dev-server 这个工具用来实现自动打包编译 下载webpack-dev-server 1$ npm i webpack-dev-server -D 配置方式1 配置package.json script 1234"server": "webpack-dev-server",//复杂配置(自动打开,端口3000,根路径src,热部署)"server": "webpack-dev-server --open --port 3000 --contentBase src --hot" 配置方式2 12345678910111213141516"server": "webpack-dev-server",// 适用于webpack4+module.exports = &#123; entry: './src/main.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;, devServer: &#123; open: true, //自动打开浏览器 port: 3000, //端口 contentBase: 'src',//设置托管根目录 hot: true //启用热更新 &#125;&#125;; 运行 1npm run name(package.json配置的name:'server') 12345//保存后会自动打包,需要更换为&lt;script src="/bundle.js"&gt;&lt;/script&gt; =&gt; localhost:8080/bundle.jsi ｢wds｣: Project is running at http://localhost:8080/i ｢wds｣: webpack output is served from /i ｢wds｣: Content not from webpack is served from L:\front_project\webpack_studyi ｢wdm｣: Hash: 3bf740352707131c0daa html-webpack-plugin安装 自动在内存中根据指定页面生成一个内存的页面 自动把打包好的bundle.js追加到页面中去 1$ npm i html-webpack-plugin -D js处理代码见下方webpack.config.js(webpack只能默认打包处理js类型文件,其他需要相应插件) 打包处理css文件(需要其他插件) 安装style-loader css-loader 1$ cnpm i style-loader css-loader -D 配置文件webpack.config.js | main.js 1234567891011121314151617181920212223242526272829const path = require('path')//导入在内存中生成html页面的插件,只要是插件都要放到plugins节点中去const htmlWebpackPlugin = require('html-webpack-plugin')module.exports = &#123; entry: './src/main.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;, plugins: [ //创建一个在内存中生成html页面的插件 new htmlWebpackPlugin(&#123; //指定模板页面,将来会根据指定的模板路径生成内存中的页面 template: path.join(__dirname,'./src/index.html'), //指定生成的页面名称 filename: 'index.html' &#125;) ], module: &#123; //这个节点用于配置所有第三方模块加载器 rules: [ //所有第三方模块的匹配规则 //配置所有.css文件的第三方loader规则 =&gt; 奇葩:调用规则是从右到左,注意顺序别写反了 &#123;test: /\.css$/,use: ['style-loader','css-loader']&#125; ] &#125;&#125;;//main.js导入import './css/style.css' 打包处理less文件 安装less 12//安装less与less loader$ npm install --save-dev less-loader less 配置文件webpack.config.js | main.js 1234567rules: [ //所有第三方模块的匹配规则(less安装试了几遍,开始一直报错,但是莫名其妙又好了) &#123;test: /\.css$/,use: ['style-loader','css-loader']&#125;, &#123;test: /\.css$/,use: ['style-loader','css-loader','less-loader']&#125;]//main.js导入import './css/style.less' 打包处理sass文件(不能使用npm,有墙) 安装sass(sass-loader依赖于node-sass) 12cnpm install node-sass -Dcnpm install sass-loader -D 配置文件webpack.config.js | main.js 123456rules: [ &#123;test: /\.scss$/,use: ['style-loader','css-loader','sass-loader']&#125;]//main.js导入import './css/style.scss' 打包处理图片 安装url-loader(依赖于file-loader) 1$ cnpm i url-loader file-loader -D 配置文件webpack.config.js 1234rules: [ //limit给定的值如果大于图片字节,采用base64编码(8为hash+name不变,后缀不变) &#123;test: /\.(jpg|png|gif|jpeg|bmp)$/,use: ['url-loader?limit=7631&amp;name=[hash:8]-[name].[ext]']&#125;] 打包处理字体文件 main.js 12//引用node_modules中文件,可以省略node_modules/,不写默认在node_modules中查找import 'bootstrap/dist/css/bootstrap.css' webpack.config.js 1234//还是使用url-loaderrules: [ &#123;test: /\.(ttf|eot|svg|woff|woff2)$/,use: ['url-loader']&#125;] babel 在webpack中,默认只能处理一部分es6的语法,一些更高级的es6甚至es7语法,webpack是处理不了的,需要借助第三方的loader,来将高级语法转为低级语法,将结果交给webpack打包到bundle.js 安装两套包 123$ cnpm i babel-loader @babel/core -D//语法插件(用于转换es)$ cnpm i @babel/preset-env @babel/polyfill -D webpack.config.js 1234rules: [ //如果不排除node_modules,则会将node_moodules中所有的第三方js文件打包编译 &#123;test: /\.js$/,use: 'babel-loader',exclude: /node_modules/&#125;] 在项目的根目录中,新建一个.babelrc的配置文件,这个配置文件属于json格式(不能写注释,字符串必须双引号) .babelrc =&gt; 有兴趣的可以去了解下babel预设 12345678910111213&#123; "presets": [ [ "@babel/preset-env", &#123; "useBuiltIns": "usage", "targets": &#123; "browsers": ["last 2 versions", "ie &gt;= 10"] &#125; &#125; ] ]&#125; 安装babel.config.js需要插件 1$ cnpm i @babel/plugin-proposal-class-properties babel.config.js 1234module.exports = &#123; //使用箭头函数还需要加入箭头函数插件(下面) plugins: [ "@babel/plugin-proposal-class-properties" ]&#125; bug解决方案: 删除node_modules,然后npm install =&gt;解决大部分问题]]></content>
      <categories>
        <category>技术</category>
        <category>webpack</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[速查表]]></title>
    <url>%2Fposts%2F1b392612%2F</url>
    <content type="text"><![CDATA[前端开发速查表 速查表集合:https://www.html.cn/dev/ 此处只对常用速查表进行展示 Javascript ES2015+ 新特性 Javascript Javascript 正则表达式 Flexbox Vuejs Vuex Angular 4 React Redux:downloaf pdf SASS Stylus GraphQL jQuery CSS3 HTML5 后端速查表Java 8 数据库mysql]]></content>
      <categories>
        <category>工具</category>
        <category>速查表</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot与安全]]></title>
    <url>%2Fposts%2F12cfed1f%2F</url>
    <content type="text"><![CDATA[Spring Boot与安全 这个是直接对教学视频做的整理,避免用到的时候又得到处搜索,视频来源(b站:https://www.bilibili.com/video/av38657363/?p=99) 测试项目请直接在此处下载基础代码进行测试:https://www.lanzous.com/i6ei0ve Spring Security引入maven123456789101112131415&lt;!-- thymeleaf --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- web --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- security --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 编写Spring Security配置类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; /** * 控制请求权限 * &lt;em&gt; * The most basic configuration defaults to automatically generating a login page at * the URL "/login", redirecting to "/login?error" for authentication failure. * &lt;/em&gt; * &lt;desc&gt; * VIP1: 只能访问/level1/** * VIP2: 只能访问/level2/** * VIP3: 只能访问/level3/** * &lt;/desc&gt; * @param http * @throws Exception */ @Override protected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() //定制请求的授权规则 .antMatchers("/").permitAll() .antMatchers("/level1/**").hasRole("VIP1") .antMatchers("/level2/**").hasRole("VIP2") .antMatchers("/level3/**").hasRole("VIP3"); //开启自动配置的登录功能,如果没有权限就进入登录页面(自带登录页面) http.formLogin(); //开启自动配置的注销功能 http.logout(); &#125; /** * 定义认证规则 * @param auth * @throws Exception */ @Override public void configure(AuthenticationManagerBuilder auth) throws Exception &#123; //定义用户(此处只是测试,实际还是应该保存在数据库) auth.inMemoryAuthentication() .passwordEncoder(new BCryptPasswordEncoder()) .withUser("zhangsan").password(new BCryptPasswordEncoder().encode("123")).roles("VIP1,VIP2") .and().withUser("lisi").password(new BCryptPasswordEncoder().encode("123")).roles("VIP2") .and().withUser("wangwu").password(new BCryptPasswordEncoder().encode("123")).roles("VIP3"); &#125;&#125; 登录功能 登出功能12&lt;!-- http.logout():The default is that accessing the URL * "/logout" will log the user out by invalidating the HTTP Session --&gt;&lt;form th:action="@&#123;/logout&#125;" th:method="post"&gt; &lt;input type="submit" value="注销"&gt;&lt;/form&gt; 错误处理 解决方法:(passwordEncoder(new BCryptPasswordEncoder())) 需求说明: 当用户没有访问权限,信息对用户隐藏 解决方案引入thymeleaf spring security支持1234&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt;&lt;/dependency&gt; 引入thymeleaf spring security名称空间welocome.html: 123&lt;html lang="es" xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org" xmlns:sec="http://www.thymeleaf.org/extras/spring-security"&gt; 错误处理 开始根据视频一直出问题,后来在github issue里面找到了解决方法: address:https://github.com/thymeleaf/thymeleaf-extras-springsecurity/issues/61 123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- 未经过身份验证 --&gt;&lt;div sec:authorize="!isAuthenticated()"&gt; &lt;h2 align="center"&gt;游客您好，如果想查看武林秘籍 &lt;a th:href="@&#123;/login&#125;"&gt;请登录&lt;/a&gt;&lt;/h2&gt;&lt;/div&gt;&lt;!-- 经过身份验证 --&gt;&lt;div sec:authorize="isAuthenticated()"&gt; &lt;h2&gt;&lt;span sec:authentication="name"&gt;&lt;/span&gt;,您好,您的角色有: &lt;span sec:authentication="principal.authorities"&gt;&lt;/span&gt;&lt;/h2&gt; &lt;form th:action="@&#123;/logout&#125;" th:method="post"&gt; &lt;input type="submit" value="注销"&gt; &lt;/form&gt;&lt;/div&gt;&lt;div sec:authorize="hasRole('VIP1')"&gt; &lt;h3&gt;普通武功秘籍&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;a th:href="@&#123;/level1/1&#125;"&gt;罗汉拳&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href="@&#123;/level1/2&#125;"&gt;武当长拳&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href="@&#123;/level1/3&#125;"&gt;全真剑法&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;div sec:authorize="hasRole('VIP2')"&gt; &lt;h3&gt;高级武功秘籍&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;a th:href="@&#123;/level2/1&#125;"&gt;太极拳&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href="@&#123;/level2/2&#125;"&gt;七伤拳&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href="@&#123;/level2/3&#125;"&gt;梯云纵&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;div sec:authorize="hasRole('VIP3')"&gt; &lt;h3&gt;绝世武功秘籍&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;a th:href="@&#123;/level3/1&#125;"&gt;葵花宝典&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href="@&#123;/level3/2&#125;"&gt;龟派气功&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href="@&#123;/level3/3&#125;"&gt;独孤九剑&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 张三只有VIP1,VIP2权限,所以VIP3对其隐藏 开启remember me功能WebSecurityConfig.java 12//开启记住我功能http.rememberMe(); 有图片可以看出,开启后会出现remember me选项(实现原理:登录成功以后,携带此cookie,只要验证通过就会免登录) 自定义登录页面1http.formLogin().usernameParameter("user").passwordParameter("pwd").loginPage("/userlogin"); 1234&lt;!-- 修改href为自定义login page requestmapping--&gt;&lt;div sec:authorize="!isAuthenticated()"&gt; &lt;h2 align="center"&gt;游客您好，如果想查看武林秘籍 &lt;a th:href="@&#123;/userlogin&#125;"&gt;请登录&lt;/a&gt;&lt;/h2&gt;&lt;/div&gt; 1234567&lt;div align="center"&gt; &lt;form th:action="@&#123;/userlogin&#125;" method="post"&gt; 用户名:&lt;input name="user"/&gt;&lt;br&gt; 密码:&lt;input name="pwd"&gt;&lt;br/&gt; &lt;input type="submit" value="登陆"&gt; &lt;/form&gt;&lt;/div&gt; 自定义remember me1http.rememberMe().rememberMeParameter("remember"); 123456789&lt;div align="center"&gt; &lt;form th:action="@&#123;/userlogin&#125;" method="post"&gt; 用户名:&lt;input name="user"/&gt;&lt;br&gt; 密码:&lt;input name="pwd"&gt;&lt;br/&gt; &lt;!-- 自定义remember me --&gt; &lt;input type="checkbox" name="remember"&gt; &lt;input type="submit" value="登陆"&gt; &lt;/form&gt;&lt;/div&gt; 资料参考: securing a web application]]></content>
      <categories>
        <category>技术</category>
        <category>Spring-Boot</category>
      </categories>
      <tags>
        <tag>security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot与任务]]></title>
    <url>%2Fposts%2F9edd11df%2F</url>
    <content type="text"><![CDATA[异步任务demo在启动类上添加@EnableAsync:开启异步注解controller 123456789101112@RestControllerpublic class AsyncController &#123; @Autowired AsyncService asyncService; @GetMapping("/hello") public String hello() &#123; asyncService.hello(); return "success"; &#125;&#125; service 12345678910111213@Servicepublic class AsyncService &#123; @Async //告诉spring这是一个异步方法 public void hello() &#123; try &#123; Thread.sleep(1000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println("处理数据中..."); &#125;&#125; 定时任务 字段 允许值 允许的特殊字符 秒 0-59 ,-/* 分 0-59 ,-/* 小时 0-23 ,-/* 日期 1-31 ,-*?/LWC 月份 1-12 ,-/* 星期 0-7或SUN-SAT,0,7是SUN ,-*?/LC# 特殊字符 代表含义 , 枚举 - 区间 / 步长 * 任意 ? 日/星期冲突匹配 L 最后 W 工作日 C 和Calendar联系后计算过的值 # 星期 4#2:第2个星期四 demo在启动类上添加@EnableScheduling//开启基于注解的定时任务 1234567891011121314/** * on the second as well as minute, hour, day of month, month and day of week. * such as &#123;@code "0 * * * * MON-FRI"&#125;:周一到周五每分钟0秒启动 * [* * * * * MON-FRI] 周一到周五每秒执行一次 * [0 0/5 14,18 * * ?] 每天14点整和18点整,每隔5分钟执行一次 * [0 15 10 ? * 1-6] 每个月的周一至周六10:15分执行一次 * [0 0 2 ? * 6L] 每个月的最后一个周六凌晨2点执行一次 * [0 0 2 LW * ?] 每个月最后一个工作日凌晨2点执行一次 * [0 0 2-4 ? * 1#1] 每个月的第一个周一凌晨2点到4点期间,每个整点执行一次 */@Scheduled(cron = "0/4 * * * * MON-FRI")public void hello() &#123; System.out.println("hello");&#125; 邮件任务starter引入1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt; 123456789101112131415161718192021222324252627@ConfigurationProperties(prefix = "spring.mail")public class MailProperties &#123; private static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8; /** * SMTP server host. For instance, `smtp.example.com`. */ private String host; /** * SMTP server port. */ private Integer port; /** * Login user of the SMTP server. */ private String username; /** * Login password of the SMTP server. */ private String password; ...&#125; 注意:想要使用qq邮箱需要开启POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务,并获取授权码 application.yml 1234567891011spring: mail: username: 1690150504@qq.com ## 敏感信息就不显示了,此处不是qq密码,而是授权码 password: **** host: smtp.qq.com properties: mail: smtp: ssl: enable: true 简单邮件发送123456789101112131415161718192021@AutowiredJavaMailSenderImpl javaMailSenderImpl;/** * 简单邮件发送 */@Testpublic void contextLoads() &#123; SimpleMailMessage message = new SimpleMailMessage(); //邮件设置 //邮件标题 message.setSubject("通知,今晚开会"); //邮件内容 message.setText("今晚7:30开会"); //收件人 message.setTo("529691071@qq.com"); //发件人 message.setFrom("1690150504@qq.com"); javaMailSenderImpl.send(message);&#125; 邮件发送成功: 复杂邮件发送1234567891011121314151617181920/** * 带附件邮件发送 */@Testpublic void sendWithFile() throws MessagingException &#123; //创建一个复杂的消息邮件 MimeMessage message = javaMailSenderImpl.createMimeMessage(); //MimeMessage mimeMessage, boolean multipart MimeMessageHelper helper = new MimeMessageHelper(message, true); //邮件设置 helper.setSubject("通知,今晚开会"); //默认不开启html helper.setText("&lt;b style='color:red'&gt;今晚7:30开会&lt;/b&gt;",true); helper.setTo("2712313163@qq.com"); helper.setFrom("1690150504@qq.com"); helper.addAttachment("1.jpg",new File("C:\\Users\\a1690\\AppData\\Roaming\\Typora\\typora-user-images\\1569326673463.png")); helper.addAttachment("2.jpg",new File("C:\\Users\\a1690\\AppData\\Roaming\\Typora\\typora-user-images\\1569330211331.png")); javaMailSenderImpl.send(message);&#125; 不过测试发现,这类邮件直接被加入了qq垃圾箱,囧 资料参考:cron表达式示例 qq邮件客户端配置 qq邮箱授权码获取]]></content>
      <categories>
        <category>技术</category>
        <category>Spring-Boot</category>
      </categories>
      <tags>
        <tag>task</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用linux命令]]></title>
    <url>%2Fposts%2F4206c037%2F</url>
    <content type="text"><![CDATA[此处列举平时经常用到的命令,免得每次使用都要查询(此处默认拥有sudo权限) 网络相关 修复网络只有127..0.0.1问题 1dhclient -v 连接vps服务器 1ssh root@服务器ip 查看本机ip 1ifconfig 权限相关 赋予管理员权限1sudo su 文件操作 递归删除根目录下所有文件(有兴趣的小伙伴可以试下) 1rm -rf /* 文件删除 1rm file_name 移动文件 1mv source dest 查看当前文件所在目录 1pwd 列举当前文件夹下文件 1ls 获取文件读写权限 1chmod 777 * 创建文件 121. echo &gt;&gt; demo.txt2. touch demo.txt 编辑文件 123456-- vi编辑文件vi file_name-- vim编辑文件vim file_name-- 编辑器编辑文件gedit file_name 创建文件夹 1mkdir directory 删除文件夹 1rmdir directory 终端操作相关 查看命令历史 1history 清空终端 1clear v2ray脚本1bash &lt;(curl -s -L https://233blog.com/v2ray.sh) 包管理 更新apt软件包 1apt-get update 安装软件包 1apt-get install package_name 搜索软件包 1apt search name]]></content>
      <categories>
        <category>技术</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>terminal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[elasticsearch上手]]></title>
    <url>%2Fposts%2Fd9b5c3c%2F</url>
    <content type="text"><![CDATA[ElasticSearch遵循restful风格;该文章只是elasticsearch入门不做详细阐述,详细信息请查看官方文档 docker安装ElasticeSearch1234567## pull ElasticSearchdocker pull elasticsearch## create networkdocker network create somenetwork## docker rundocker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" elasticsearch:tag ElasticSearch测试 示例参考权威指南中文版:索引员工文档(此处使用postman来进行测试)。DELEATE,HEAD请求有兴趣的朋友可以试下,这儿就不一一试了 PUT请求 GET请求数据存入后,我们再通过get请求来试着进行下查询 数据存在 数据不存在 查询所有员工信息1GET /megacorp/employee/_search 搜索姓名为smith的员工12345678910## 使用轻量搜索进行查询GET /megacorp/employee/_search?q=last_name:Smith## 查询表达式进行查询&#123; "query" : &#123; "match" : &#123; "last_name" : "Smith" &#125; &#125;&#125; Spring Boot整合ElasticSearchSpringBoot支持两种技术来实现与ES交互(1:Jest 2.SpringData ElasticSearch) Jest简单上手从JestAutoConfiguration可以得知,如果使用Jest需要导入对应的包,版本需要和version保持一致 12345&lt;dependency&gt; &lt;groupId&gt;io.searchbox&lt;/groupId&gt; &lt;artifactId&gt;jest&lt;/artifactId&gt; &lt;version&gt;6.3.1&lt;/version&gt; &lt;/dependency&gt; 123456789101112131415161718192021@ConfigurationProperties(prefix = "spring.elasticsearch.jest")public class JestProperties &#123; /** * Comma-separated list of the Elasticsearch instances to use. * 默认:http://localhost:9200 */ private List&lt;String&gt; uris = new ArrayList&lt;&gt;(Collections.singletonList("http://localhost:9200")); /** * Login username. */ private String username; /** * Login password. */ private String password; ...&#125; 配置yml 1234spring: elasticsearch: jest: uris: http://192.168.91.131:9200 创建article bean 12345678public class Article &#123; @JestId private Integer id; private String author; private String title; private String content; ...&#125; 测试类 12345678910111213141516@AutowiredJestClient jestClient;@Testpublic void contextLoads() throws IOException &#123; //1.给Es索引(保存)一个文档 Article article = new Article(); article.setId(1); article.setAuthor("john"); article.setTitle("震惊!..."); article.setContent("page"); //索引.类型.编号(类似:/megacorp/employee/1示例,此处已经在bean里面指定了id) Index index = new Index.Builder(article).index("lsj").type("article").build(); jestClient.execute(index);&#125; 发送请求进行测试 测试搜索 1234567891011121314151617/** * 测试搜索 */@Testpublic void search() throws IOException &#123; String json = "&#123;\n" + " \"query\" : &#123;\n" + " \"match\" : &#123;\n" + " \"author\" : \"john\"\n" + " &#125;\n" + " &#125;\n" + "&#125;"; Search search = new Search.Builder(json).addIndex("lsj").addType("article").build(); SearchResult result = jestClient.execute(search); //&#123;"took":511,"timed_out":false,"_shards":&#123;"total":5,"successful":5,"skipped":0,"failed":0&#125;,"hits":&#123;"total":1,"max_score":0.2876821,"hits":[&#123;"_index":"lsj","_type":"article","_id":"1","_score":0.2876821,"_source":&#123;"id":1,"author":"john","title":"震惊!...","content":"page"&#125;&#125;]&#125;&#125; System.out.println(result.getJsonString());&#125; 简单上手SpringData ElasticSearch- 引入starter 引入starter 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt; &lt;/dependency&gt; 配置yml 12345spring: data: elasticsearch: cluster-name: docker-cluster cluster-nodes: 192.168.91.131:9300 cluster-name需要一致 使用ElasticsearchRepository测试1234567@Document(indexName = "lsj",type = "book")public class Book &#123; private Integer id; private String bookName; private String author; ...&#125; 123456789public interface BookRepository extends ElasticsearchRepository&lt;Book,Integer&gt; &#123; /** * search by bookName * @param bookName * @return */ List&lt;Book&gt; findByBookNameLike(String bookName);&#125; 123456789101112@Testpublic void repository() &#123; // 新增测试 Book book = new Book(); book.setAuthor("lsj"); book.setBookName("harry"); book.setId(1); bookRepository.index(book); //查询测试 List&lt;Book&gt; result = bookRepository.findByBookNameLike("harry");&#125; 资料参考:docker:elasticsearch elasticsearch权威指南中文版 springboot elasticsearch docs]]></content>
      <categories>
        <category>技术</category>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery插件$.fn]]></title>
    <url>%2Fposts%2Fdc1ef41d%2F</url>
    <content type="text"><![CDATA[因为这段时间一直在做后端的开发,再加上以前对$.fn有点儿不清楚,所以专门写篇博客加深理解,错误的地方希望指正。($.fn即jQuery.fn) $.fn源码jQuery.fn源码:从源码可以看出$.fn实际就是jQuery的原型,生成一个Object实例对象 123456789101112jQuery.fn = jQuery.prototype = &#123; // The current version of jQuery being used jquery: version, constructor: jQuery, // The default length of a jQuery object is 0 length: 0 ...&#125; 我们可以试着打印$.fn会发现它是一个Object对象,内部包含jquery的方法及属性 $.fn进行扩展示例:通过$.fn修改颜色 123456789&lt;h1 id="word"&gt;HELLO WORLD&lt;/h1&gt;&lt;script&gt; $.fn.red = function()&#123; this.css(&#123;"color":"red"&#125;); &#125; $(function() &#123; $("#word").red(); &#125;)&lt;/script&gt; $.fn.extend此处就直接引官网的api说明 Description: Merge the contents of an object onto the jQuery prototype to provide new jQuery instance methods.(大意是将对象的内容合并到jQuery原型上，以提供新的jQuery实例方法) 示例:通过jQuery.fn.extend对复选框进行选中以及取消选中 12345678910111213141516171819&lt;span&gt;&lt;input type="checkbox" name="huawei"&gt;华为&lt;/span&gt;&lt;span&gt;&lt;input type="checkbox" name="xiaomi"&gt;小米&lt;/span&gt;&lt;script&gt;jQuery.fn.extend (&#123; check: function() &#123; return this.each(function() &#123; this.checked = true; &#125;); &#125;, uncheck: function() &#123; return this.each(function() &#123; this.checked = false; &#125;) &#125;&#125;)$(function() &#123; $("input[type='checkbox']").check();&#125;)&lt;/script&gt; 示例2:通过jQuery.fn.extend实现点击编辑框弹出编辑框内容 1234567891011&lt;textarea id="edit"&gt;&lt;/textarea&gt;&lt;script&gt; jQuery.fn.extend (&#123; alertWhileClick: function() &#123; $(this).click(function() &#123; alert($(this).val()); &#125;) &#125; &#125;) $("#edit").alertWhileClick();&lt;/script&gt; $.extend Description: Merge the contents of two or more objects together into the first object.(大意是将两个或多个对象的内容合并到第一个对象中。) 示例:实例对象合并 123456let apple = &#123;color:"red",price:1.0,limit:2&#125;;let banana = &#123;color:&#123;color1:"yellow",color2:"green"&#125;,price:2.0&#125;;$.extend(apple,banana);$(function() &#123; $("#log").append(JSON.stringify(apple));&#125;) 资料参考: jQuery.fn.extend api jQuery.extend api]]></content>
      <categories>
        <category>技术</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[整合rabbitMQ]]></title>
    <url>%2Fposts%2F3b2e564b%2F</url>
    <content type="text"><![CDATA[docker启动rabbitMQ123456-- 安装rabbitMQ带后台管理界面(带management),推荐使用daocloud加速,速度特别快$ docker pull rabbitmq:management-alpine-- docker后台运行(5672:服务器与客户端交互端口,15672:web管理界面端口)$ docker run -d -p 5672:5672 -p 15672:15672 --name myrabbitmq IMAGE_ID-- 进入rabbitmq后台(name:guest;password:guest)127.0.0.1:15672 导入maven依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 项目Demo消息发送 RabbitProperties:封装了RabbitMQ的配置RabbitTemplate:给RabbitMQ发送和接收消息AmqpAdmin:RabbitMQ系统管理功能组建 1234567891011121314151617181920212223242526 @Autowired RabbitTemplate rabbitTemplate;/** * 1.单播模式(点对点):direct */ @Test public void contextLoads() &#123; //Message需要自己构造一个;定义消息体内容和消息头 //rabbitTemplate.send(exchange,routingKey,message); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("msg","hello world"); map.put("data", Arrays.asList("hi",1)); //对象被默认序列化后发送出去(广播模式可以陆由键为"") rabbitTemplate.convertAndSend("exchange.direct","atguigu.news",map); &#125; /** * 接收消息 */ @Test public void receive() &#123; //填写消息队列名称 Object obj = rabbitTemplate.receiveAndConvert("atguigu.news"); System.out.println(obj);//&#123;msg=hello world, data=[hi, 1]&#125; &#125; 默认序列化使用application/x-java-serialized-object 如何将消息转化为json? 123456789101112@Configurationpublic class MyAmqpConfig &#123; /** * 消息序列化为json * @return */ @Bean public MessageConverter messageConverter() &#123; return new Jackson2JsonMessageConverter(); &#125;&#125; rabbitmq发送对象 1234567891011121314151617 @Autowired RabbitTemplate rabbitTemplate;/** * 1.单播模式(点对点):direct */ @Test public void contextLoads() &#123; //Message需要自己构造一个;定义消息体内容和消息头 //rabbitTemplate.send(exchange,routingKey,message); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("msg","hello world"); map.put("data", Arrays.asList("hi",1)); //对象被默认序列化后发送出去 rabbitTemplate.convertAndSend("exchange.direct","atguigu.news",new Book("西游记","吴承恩")); &#125; 进行消息监听1234567891011/**消息监听启动需要在application启动类上添加@EnableRabbit注解*/@Servicepublic class BookService &#123; //监听队列 @RabbitListener(queues = "atguigu.news") public void receive(Book book) &#123; System.out.println("收到消息"+book); &#125;&#125; 创建交换器1234567891011121314151617@AutowiredAmqpAdmin amqpAdmin;/** * 创建交换器 */@Testpublic void createExchange() &#123; //创建交换器 amqpAdmin.declareExchange(new DirectExchange("lsj.direct")); //创建队列 amqpAdmin.declareQueue(new Queue("test.queue")); //创建绑定规则 amqpAdmin.declareBinding(new Binding("test.queue", Binding.DestinationType.QUEUE,"lsj.direct","hh",null)); System.out.println("创建完成");&#125;]]></content>
      <categories>
        <category>技术</category>
        <category>消息</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用git命令]]></title>
    <url>%2Fposts%2F335a5d78%2F</url>
    <content type="text"><![CDATA[绪论:因为经常用到git命令,常用命令时常记不住,所以在此处对常用git命令做个记录 新建代码库在当前目录新建一个git仓库1$ git init 新建一个目录并初始化为git仓库1$ git init [project-name] Clone project1$ git clone [url] 配置显示当前的git配置1$ git config --list 配置git提交的用户信息12$ git config [--global] user.name "name"$ git config [--global] user.email "email" 增加/删除文件添加指定文件到暂存区1$ git add [file1] [file2] ... 添加指定目录到暂存区1$ git add [dir] 添加当前目录的所有文件到暂存区1$ git add . 添加每个变化前都会要求确认/对于同一文件的多处变化可以实现分次提交1$ git add -p 删除工作分区文件,并将这次删除放入暂存区1$ git rm [file1] [file2] ... 停止追踪指定文件,但该文件会保留在工作区1$ git rm --cached [file] 改名文件,并将这个改名放入暂存区1$ git mv [file-origin] [file-renamed] 代码提交提交暂存区到仓库区1$ git commit -m [message] 提交暂存区的指定文件到仓库区1$ git commit [file1] [file2] ... -m [message] 提交工作区自上次commit后的变化,直接到仓库区1$ git commit -a 提交时显示所有diff信息1$ git commit -v 使用一次新的commit,替代上一次提交1$ git commit --amend -m [message] 重做上一次commit,并包括指定文件的新变化1$ git commmit -amend [file1] [file2] ... 分支列出所有本地分支1$ git branch 列出所有远程分支1$ git branch -r 列出所有本地分支和远程分支1$ git branch -a 新建一个分支,但仍然停留在当前分支1$ git branch [branch-name] 新建一个分支,并切换到该分支1$ git checkout -b [branch-name] 新建一个分支,指向指定commit1$ git branch [branch] [commit] 新建一个分支,与指定的远程分支建立追踪关系1$ git branch --track [branch] [remote-branch] 切换到指定分支,并更新工作区1$ git checkout [branch-name] 切换到上一个分支1$ git checkout - 建立追踪关系,在现有分支与指定的远程分支之间1$ git branch --set-upstream [branch] [remote-branch] 合并指定分支到当前分支1$ git merge [branch] 选择一个commit,合并进当前分支1$ git cherry-pick [commit] 删除分支1$ git branch -d [branch-name] 删除远程分支12$ git push prigin --delete [branch-name]$ git branch -dr [remote/branch] 标签列出所有tag1$ git tag 新建一个tag在当前commit1$ git tage [tag] 新建一个tag在指定commit1$ git tag [tag] [commit] 删除本地tag1$ git tag -d [tag] 删除远程tag1$ git push origin :refs/tags/[tagName] 查看tag信息1$ git show [tag] 提交指定tag1$ git push [remote] [tag] 提交所有tag1$ git push [remote] --tags 新建一个分支,指向某个tag1$ git checkout -b [branch] [tag] 查看信息查看有变更的文件1$ git status 显示当前分支的版本历史1$ git log 显示commit历史,以及每一次commit发生变更的文件1$ git log --stat 搜索提交历史,根据关键字1$ git log -S [keyword] 显示某个commit之后的所有变动,每个commit占据一行1$ git log [tag] HEAD --pretty=format:%s 显示某个commiy之后的所有变动,其提交说明必须符合搜索条件1$ git log [tag] HEAD --grep feature 显示某个文件的版本历史,包括文件改名12$ git log --follow [file]$ git whatchanged [file] 显示指定文件的每一次diff1$ git log -p [file] 显示过去5次提交1$ git log -5 --pretty --online 显示所有提交过的用户,按提交次数排序1$ git shortlog -sn 显示指定文件是什么人在什么时间修改过1$ git blame [file] 显示暂存区和工作区的差异1$ git diff 显示暂存区和上一次commit的差异1$ git diff --cached [file] 显示工作区与当前分支最新commit之间的差异1$ git diff [first-branch] ... [second-branch] 显示今天你写了多少行代码1$ git diff --shortstat "@&#123;0 day ago&#125;" 显示某次提交的元数据和内容变化1$ git show [commit] 显示某次提交发生变化的文件1$ git show --name-only [commit] 显示某次提交时,某个文件的内容1$ git show [commit]:[filename] 显示当前分支的最近几次提交1$ git reflog 远程同步下载远程仓库的所有变动1$ git fetch [remote] 显示所有远程仓库1$ git remote -v 显示某个远程仓库的信息1$ git remote show [remote] 增加一个新的远程仓库,并命名1$ git remote add [shortname] [url] 取回远程仓库的变化,并与本地分支合并1$ git pull [remote] [branch] 上传本地指定分支到远程仓库1$ git push [remote] [branch] 强行推送当前分支到远程仓库,即使有冲突1$ git push [remote] --force 推送所有分支到远程仓库1$ git push [remote] --all 撤销恢复暂存区的指定文件到工作区1$ git checkout [file] 恢复某个commit的指定文件到暂存区和工作区1$ git checkout [commit] [file] 恢复暂存区的所有文件到工作区1$ git checkout . 重置暂存区的指定文件,与上次commit保持一致,但工作区不变1$ git reset [file] 重置暂存区与工作区,与上一次commit保持一致1$ git reset --hard 重置当前分支的指针为指定commit,同时重置暂存区,但工作区不变1$ git reset [commit] 重置当前分支的HEAD为指定commit,同时重置暂存区和工作区,与指定commit一致1$ git reset --hard [commit] 重置当前HEAD为指定commit,但保持暂存区和工作区保持不变1$ git reset --keep [commit] 新建一个commit,用来撤销指定commit,后者的所有变化都将被前者抵消,并应用到当前分支1$ git revert [commit] 暂时将未提交的变化移出,稍后再移入12$ git stash$ git stash pop 其他生成可供发布的压缩包1$ git archive]]></content>
      <categories>
        <category>技术</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java实现生产者与消费者]]></title>
    <url>%2Fposts%2Fc0369f57%2F</url>
    <content type="text"><![CDATA[本文属于转载,因为发现挺重要,所以在此记录下 生产者和消费者问题是线程模型中的经典问题：生产者和消费者在同一时间段内共用同一个存储空间，生产者往存储空间中添加产品，消费者从存储空间中取走产品，当存储空间为空时，消费者阻塞，当存储空间满时，生产者阻塞。 wait()和notify()方法的实现 缓冲区满和为空时都调用wait()方法等待，当生产者生产了一个产品或者消费者消费了一个产品之后会唤醒所有线程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * 消费者/生产者 * @author 刘世杰 * @date 2019/8/11 */public class ThreadDemo &#123; private static Integer count = 0; private static final Integer Full = 10; private static String Lock = "lock"; public static void main(String[] args) &#123; ThreadDemo demo = new ThreadDemo(); new Thread(demo.new Producer()).start(); new Thread(demo.new Producer()).start(); new Thread(demo.new Consumer()).start(); &#125; class Producer implements Runnable&#123; @Override public void run() &#123; for(;;) &#123; try &#123; Thread.sleep(3000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; synchronized (Lock) &#123; while (count == Full) &#123; try &#123; Lock.wait(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; count++; System.out.println(Thread.currentThread().getName()+"生产者生产,目前总共有"+count); Lock.notifyAll(); &#125; &#125; &#125; &#125; class Consumer implements Runnable&#123; @Override public void run() &#123; for (;;) &#123; try &#123; Thread.sleep(3000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; synchronized (Lock) &#123; while (count == 0) &#123; try &#123; Lock.wait(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; count--; System.out.println(Thread.currentThread().getName()+"消费者消费,目前总共有"+count); Lock.notifyAll(); &#125; &#125; &#125; &#125;&#125; 结果: 12345678Thread-0生产者生产,目前总共有1Thread-3消费者消费,目前总共有0Thread-2生产者生产,目前总共有1Thread-1消费者消费,目前总共有0Thread-0生产者生产,目前总共有1Thread-3消费者消费,目前总共有0Thread-2生产者生产,目前总共有1Thread-1消费者消费,目前总共有0 可重入锁ReentrantLock的实现 java.util.concurrent.lock 中的 Lock 框架是锁定的一个抽象，通过对lock的lock()方法和unlock()方法实现了对锁的显示控制，而synchronize()则是对锁的隐性控制。可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响，简单来说，该锁维护这一个与获取锁相关的计数器，如果拥有锁的某个线程再次得到锁，那么获取计数器就加1，函数调用结束计数器就减1，然后锁需要被释放两次才能获得真正释放。已经获取锁的线程进入其他需要相同锁的同步代码块不会被阻塞。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * 可重用锁实现生产者/消费者 * @author 刘世杰 * @date 2019/8/11 */public class ThreadDemo02 &#123; private static Integer count = 0; private static final Integer FULL = 10; //创建一个锁对象 private Lock lock = new ReentrantLock(); //创建两个条件变量,一个为缓冲区未满,一个为缓冲区非空 private final Condition notFull = lock.newCondition(); private final Condition notEmpty = lock.newCondition(); public static void main(String[] args) &#123; ThreadDemo02 demo02 = new ThreadDemo02(); new Thread(demo02.new Producer()).start(); new Thread(demo02.new Consumer()).start(); new Thread(demo02.new Producer()).start(); new Thread(demo02.new Consumer()).start(); &#125; class Producer implements Runnable &#123; @Override public void run() &#123; for (;;) &#123; try &#123; Thread.sleep(3000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //获取锁 lock.lock(); try &#123; while(count == FULL) &#123; try &#123; notFull.await(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; count++; System.out.println(Thread.currentThread().getName()+"生产者生产,当前总共"+count); //唤醒消费者 notEmpty.signal(); &#125; finally &#123; //释放锁 lock.unlock(); &#125; &#125; &#125; &#125; class Consumer implements Runnable &#123; @Override public void run() &#123; for(;;) &#123; try &#123; Thread.sleep(3000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //获取锁 lock.lock(); try &#123; while(count == 0) &#123; try &#123; notEmpty.await(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; count--; System.out.println(Thread.currentThread().getName()+"消费者消费,当前总共"+count); //唤醒生产者 notFull.signal(); &#125; finally &#123; //释放锁 lock.unlock(); &#125; &#125; &#125; &#125;&#125; 阻塞队列BlockingQueue的实现BlockingQueue即阻塞队列，从阻塞这个词可以看出，在某些情况下对阻塞队列的访问可能会造成阻塞。被阻塞的情况主要有如下两种: 当队列满了的时候进行入队列操作 当队列空了的时候进行出队列操作因此，当一个线程对已经满了的阻塞队列进行入队操作时会阻塞，除非有另外一个线程进行了出队操作，当一个线程对一个空的阻塞队列进行出队操作时也会阻塞，除非有另外一个线程进行了入队操作。从上可知，阻塞队列是线程安全的。下面是BlockingQueue接口的一些方法: 操作 抛异常 特定值 阻塞 超时 插入 add(o) offer(o) put(o) offer(o, timeout, timeunit) 移除 remove(o) poll(o) take(o) poll(timeout, timeunit) 检查 element(o) peek(o) 这四类方法分别对应的是：1 . ThrowsException：如果操作不能马上进行，则抛出异常2 . SpecialValue：如果操作不能马上进行，将会返回一个特殊的值，一般是true或者false3 . Blocks:如果操作不能马上进行，操作会被阻塞4 . TimesOut:如果操作不能马上进行，操作会被阻塞指定的时间，如果指定时间没执行，则返回一个特殊值，一般是true或者false下面来看由阻塞队列实现的生产者消费者模型,这里我们使用take()和put()方法，这里生产者和生产者，消费者和消费者之间不存在同步，所以会出现连续生成和连续消费的现象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.BlockingQueue;/** * BlockingQueue实现生产者/消费者 * @author 刘世杰 * @date 2019/8/11 */public class ThreadDemo03 &#123; private static Integer count = 0; //创建一个阻塞队列 final BlockingQueue blockingQueue = new ArrayBlockingQueue&lt;&gt;(10); public static void main(String[] args) &#123; ThreadDemo03 demo03 = new ThreadDemo03(); new Thread(demo03.new Producer()).start(); new Thread(demo03.new Consumer()).start(); &#125; class Producer implements Runnable &#123; @Override public void run() &#123; for (;;) &#123; try &#123; Thread.sleep(3000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; try &#123; blockingQueue.put(1); count++; System.out.println(Thread.currentThread().getName() + "生产者生产，目前总共有" + count); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; class Consumer implements Runnable &#123; @Override public void run() &#123; for(;;) &#123; try &#123; Thread.sleep(3000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; try &#123; blockingQueue.take(); count--; System.out.println(Thread.currentThread().getName() + "消费者消费，目前总共有" + count); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 信号量Semaphore的实现 Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源，在操作系统中是一个非常重要的问题，可以用来解决哲学家就餐问题。Java中的Semaphore维护了一个许可集，一开始先设定这个许可集的数量，可以使用acquire()方法获得一个许可，当许可不足时会被阻塞，release()添加一个许可。在下列代码中，还加入了另外一个mutex信号量，维护生产者消费者之间的同步关系，保证生产者和消费者之间的交替进行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.util.concurrent.Semaphore;/** * Semaphore实现生产者/消费者 * @author 刘世杰 * @date 2019/8/11 */public class ThreadDemo04 &#123; private static Integer count = 0; //创建三个信号变量 final Semaphore notFull = new Semaphore(10); final Semaphore notEmpty = new Semaphore(0); final Semaphore mutex = new Semaphore(1); public static void main(String[] args) &#123; ThreadDemo04 demo04 = new ThreadDemo04(); new Thread(demo04.new Producer()).start(); new Thread(demo04.new Consumer()).start(); &#125; class Producer implements Runnable &#123; @Override public void run() &#123; for (;;) &#123; try &#123; Thread.sleep(3000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; try &#123; notFull.acquire(); mutex.acquire(); count++; System.out.println(Thread.currentThread().getName() + "生产者生产，目前总共有" + count); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; mutex.release(); notEmpty.release(); &#125; &#125; &#125; &#125; class Consumer implements Runnable &#123; @Override public void run() &#123; for (;;) &#123; try &#123; Thread.sleep(3000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; try &#123; notEmpty.acquire(); mutex.acquire(); count--; System.out.println(Thread.currentThread().getName() + "消费者消费，目前总共有" + count); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; mutex.release(); notFull.release(); &#125; &#125; &#125; &#125;&#125; 管道输入输出流PipedInputStream和PipedOutputStream实现 在java的io包下，PipedOutputStream和PipedInputStream分别是管道输出流和管道输入流。它们的作用是让多线程可以通过管道进行线程间的通讯。在使用管道通信时，必须将PipedOutputStream和PipedInputStream配套使用。使用方法：先创建一个管道输入流和管道输出流，然后将输入流和输出流进行连接，用生产者线程往管道输出流中写入数据，消费者在管道输入流中读取数据，这样就可以实现了不同线程间的相互通讯，但是这种方式在生产者和生产者、消费者和消费者之间不能保证同步，也就是说在一个生产者和一个消费者的情况下是可以生产者和消费者之间交替运行的，多个生成者和多个消费者者之间则不行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import java.io.IOException;import java.io.PipedInputStream;import java.io.PipedOutputStream;/** * 使用管道实现生产者/消费者 * @author 刘世杰 * @date 2019/8/11 */public class ThreadDemo05 &#123; final PipedInputStream pis = new PipedInputStream(); final PipedOutputStream pos = new PipedOutputStream(); &#123; try &#123; pis.connect(pos); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; ThreadDemo05 demo05 = new ThreadDemo05(); new Thread(demo05.new Producer()).start(); new Thread(demo05.new Consumer()).start(); new Thread(demo05.new Consumer()).start(); &#125; class Producer implements Runnable &#123; @Override public void run() &#123; try &#123; while(true) &#123; Thread.sleep(3000); int num = (int)(Math.random() * 255); System.out.println(Thread.currentThread().getName() + "生产者生产了一个数字，该数字为： " + num); pos.write(num); pos.flush(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; pos.close(); pis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; class Consumer implements Runnable &#123; @Override public void run() &#123; try &#123; while(true) &#123; Thread.sleep(3000); int num = pis.read(); System.out.println("消费者消费了一个数字，该数字为：" + num); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; pos.close(); pis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 1234567891011121314151617181920Thread-0生产者生产了一个数字，该数字为： 118消费者消费了一个数字，该数字为：118Thread-0生产者生产了一个数字，该数字为： 94消费者消费了一个数字，该数字为：94Thread-0生产者生产了一个数字，该数字为： 107消费者消费了一个数字，该数字为：107Thread-0生产者生产了一个数字，该数字为： 140消费者消费了一个数字，该数字为：140Thread-0生产者生产了一个数字，该数字为： 225消费者消费了一个数字，该数字为：225Thread-0生产者生产了一个数字，该数字为： 66消费者消费了一个数字，该数字为：66Thread-0生产者生产了一个数字，该数字为： 154消费者消费了一个数字，该数字为：154Thread-0生产者生产了一个数字，该数字为： 69消费者消费了一个数字，该数字为：69Thread-0生产者生产了一个数字，该数字为： 226消费者消费了一个数字，该数字为：226Thread-0生产者生产了一个数字，该数字为： 178消费者消费了一个数字，该数字为：178 资料来源: java实现生产者消费者]]></content>
      <categories>
        <category>技术</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用docker实现nginx反向代理]]></title>
    <url>%2Fposts%2F92d34c63%2F</url>
    <content type="text"><![CDATA[本文使用技术栈:dokcer,nginx,ubuntu18.04,openssl docker运行nginx docker pull 1docker pull nginx docker查看镜像库 1docker images docker后台运行 1docker container run -d -p 127.0.0.2:8080:80 --name nginx-proxy nginx -d：在后台运行 -p ：容器的80端口映射到127.0.0.2:8080 --rm：容器停止运行后，自动删除容器文件 --name：容器的名字为mynginx 映射网页目录 网页都在容器内不便于修改,所以需要网页目录映射本地 123456789101112131415161718$ mkdir nginx-docker-demo$ cd nginx-docker-demo## 该目录下新建index.html$ echo &gt;&gt; index.html## 需要停止原有容器-此次127.0.0.2:8080就可以看见index.html内容了$ docker container run \ -d \ -p 127.0.0.2:8080:80 \ --rm \ --name mynginx \ --volume "$PWD/html":/usr/share/nginx/html \ nginx## 容器停止$ docker container stop mynginx 拷贝配置12345678## 此时本地会多出一个nginx子目录$ docker container cp mynginx:/etc/nginx .## 子目录更名为confmv nginx conf## 此时就可以关闭nginx了$ docker container stop mynginx 映射配置目录1234567891011## 重新启动新的容器docker container run \ --rm \ --name mynginx \ --volume "$PWD/html":/usr/share/nginx/html \ --volume "$PWD/conf":/etc/nginx \ -p 127.0.0.2:8080:80 \ -d \ nginx ## 访问127.0.0.2:8080 如果成功则配置完成 自签名证书–此处通过openssl openssl安装 12sudo apt-get install opensslsudo apt-get install libssl-dev 进行自签名 1234567$ sudo openssl req \ -x509 \ -nodes \ -days 365 \ -newkey rsa:2048 \ -keyout example.key \ -out example.crt 如上参数说明： req：处理证书签署请求。 -x509：生成自签名证书。 -nodes：跳过为证书设置密码的阶段，这样 Nginx 才可以直接打开证书。 -days 365：证书有效期为一年。 -newkey rsa:2048：生成一个新的私钥，采用的算法是2048位的 RSA。 -keyout：新生成的私钥文件为当前目录下的example.key。 -out：新生成的证书文件为当前目录下的example.crt。 自签名后会要求填写一些信息,正式证书需要CA签名 12## 最重要的一条信息Common Name (e.g. server FQDN or YOUR name) []:127.0.0.2 回答完问题后当前目录下会多出两个文件:example.key和example.crt 123## conf目录下新建certs目录--将文件放入cert目录$ mkdir conf/certs$ mv example.crt example.key conf/certs 有了密钥和证书就可以打开nginx的https了 打开如下文件: conf/conf.d/default.conf 123456789101112131415161718192021## 将server放入最后server &#123; ## 443端可以是https的专用端口 listen 443 ssl http2; server_name localhost; ssl on; ssl_certificate /etc/nginx/certs/example.crt; ssl_certificate_key /etc/nginx/certs/example.key; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / &#123; root /usr/share/nginx/html; index index.html index.htm; &#125;&#125; 重新启动nginx容器 12345678910## 注意:$PWD表示当前路径-小心不要入坑$ docker container run \ --rm \ --name mynginx \ --volume "$PWD/html":/usr/share/nginx/html \ --volume "$PWD/conf":/etc/nginx \ -p 127.0.0.2:8080:80 \ -p 127.0.0.2:8081:443 \ -d \ nginx 此时就可以通过127.0.0.2:8080和127.0.0.2:8081进行访问可以看见html内容,因为是自签名所以会报不安全 资料参考:nginx容器教程-阮一峰]]></content>
      <categories>
        <category>技术</category>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vps建站]]></title>
    <url>%2Fposts%2F2fbc60fa%2F</url>
    <content type="text"><![CDATA[工具使用–很多地方需要翻墙,如果不能可寻求替代方案 vps - vultr(搭建服务器) namesilo(域名注册) 宝塔linux ubuntu18.04 wordpress(博客框架-也可以放入自己的代码) vultrvultr官网 vultr的另一类用途不解释-社会主义 [vultr注册充值]-网上很多教程vultr创建服务器 点击deploy new server 选择server-location(推荐日本节点) 选择server-type(我的是ubuntu18.04) 选择server-size,如果只是小型网站,可以选择$5/月 然后选择Deploy Now 然后进入products,等待一会儿服务器status变为running即可-可以通过ping测试 7.点击进入-查看相关信息 namesilonamesilo官网 购买域名 直接搜索namesilo域名购买与使用教程,网上很多资料 域名解析(重要)manage my domains-&gt;进入如下界面点击如下按钮 点击后会进入如下页面 说明:此处的ipv4 address使用前面vps查看相关信息的ip,因为namesilo域名解析速度有点儿慢,所以最多可能要等几个小时,可以通过ping renoblog.xyz来测试(不能ping通就继续等),直到能ping通为止 宝塔linux宝塔linux官网 ubuntu一键安装脚本,其他系统也可以在里面找到 wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh &amp;&amp; sudo bash install.sh 如下是vps的详细信息,待会儿会用到 然后进入linux终端(需要sudo) 123ssh root@198.13.35.151## 接下来会提示输入密码(直接复制粘贴即可,密码是隐藏的)## 稍微等会儿,将刚才的一键安装脚本粘贴进入,然后等待运行 然后等待安装后能看到url,user,password-因为已经安装过了,所以我只能查找下,可能与第一次安装有所区别,但是没影响 密码找回,如果不小心关了终端,可以ssh进入然后bt default命令 查询url网址,然后输入user,password,会进入如下页面-如果出现运行环境不对,可以在软件商店更换运行环境 安装完成后,点击网站-&gt;添加网站 域名填写自己的域名即可,如果是静态网站可以选择不安装 进入网站-&gt;根目录,进入如下页面,我使用的wordpress,网站目录就不介绍了,我直接使用的wordpress,导入wordpress并解析所有文件且放入根目录即可通过域名进入 其他安全设置,监控,ftp自行查询 wordpresswordpress下载 下载wordpress模板,如果是自己的网站模板也可以 然后输入域名就可以进入wordpress后台了,接下来的操作都很简单,就不一一介绍了]]></content>
      <categories>
        <category>技术</category>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>site</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO详解]]></title>
    <url>%2Fposts%2F88bb8d2a%2F</url>
    <content type="text"><![CDATA[概览Java的io大概可以分为以下分类 磁盘操作：File 字节操作:Inputstream和OutputStream 字符操作:Reader和Writer 对象操作:Serializable 网络操作:Scoket 新的输入和输出:NIO 磁盘操作File类可以用于表示文件的目录和信息,不表示文件的内容 123456789101112131415/*** 递归获取目录下所有文件*/void diskOperate(File file) &#123; if(file == null || !file.exists()) &#123; return; &#125; if(file.isFile()) &#123; System.out.println(file.getName()); return; &#125; for (File fi : file.listFiles()) &#123; diskOperate(fi); &#125;&#125; 字节操作1234567891011121314151617/** * 字节实现文件复制- * 此处省略了未进行详细文件类型以及文件是否存在判断 * @param src * @param dist */void copyFile(String src,String dist) throws IOException &#123; FileInputStream in = new FileInputStream(src); FileOutputStream out = new FileOutputStream(dist); byte[] buffer = new byte[20*1024]; int cnt; while((cnt = in.read(buffer,0,buffer.length)) != -1) &#123; out.write(buffer,0,cnt); &#125; in.close(); out.close();&#125; BufferedInputStream为FileInputStream提供缓存功能(装饰者模式)1BufferedInputStream in = new BufferedInputStream(new FileInputStream(file)); 字符操作编码就是将字符转为字节,解码就是将字节转为字符如果编码和解码过程中采用了不同的编码方式就会出现乱码 GBK:中文字符占2个字节,英文字符占1个字符 UTF-8：中文字符占3个字节,英文字符占1个字节 UTF-16be:中文和英文字符占2个字节1234String str1 = "中文";//getBytes的默认编码方式与平台有关byte[] bytes = str1.getBytes("UTF-8");String str2 = new String(bytes,"UTF-8");//中文 Read与Writter InputStreamReader: 实现从字节流解码为字符流 OutputStream:实现字符流解码为字节流12345678910111213/*** 逐行输出文本文件内容* @throws IOException*/void progressivePrint(String path) throws IOException&#123; FileReader reader = new FileReader(path); BufferedReader bufferedReader = new BufferedReader(reader); String line; while((line = bufferedReader.readLine()) != null) &#123; System.out.println(line); &#125; bufferedReader.close();&#125; 对象操作序列化:就是将一个对象转为字节序列,方便存储和传输(–便于网络传输等,比如在windows上序列化对象,可以在unix上完整还原,无视平台差异) 序列化:ObjectOutputStream.writeObject() 反序列化:ObjectInputStream.readObject() 不会对静态变量进行序列化,因为静态变量属于类的状态,序列化只是保存对象的状态 序列化的类需要实现Serializzable接口(标准-没有方法实现),但是不实现会抛出异常 使用transient可以避免属性被序列化 1private transient Object[] elementData; 对序列化感兴趣的可以查阅资料,此处不进行详细描述 网络操作java中的网络支持 InetAddress:用于表示网络上的硬件资源,即ip地址 URL：统一资源定位符 Sockets:使用tcp协议实现网络通信 Datagram:使用UDP协议实现网络通信InetAddress没有公有的构造函数,只能通过静态方法来创建实例InetAddress.getByName(String host);InetAddress.getByAddress(byte[] address); URL123456789101112131415161718/** * 直接从URL中获取字节流数据 */void netOperate() throws MalformedURLException,IOException &#123; URL url = new URL("https://www.baidu.com"); /* 字节流 */ InputStream in = url.openStream(); /* 字符流 */ InputStreamReader reader = new InputStreamReader(in,"utf-8"); /* 提供缓存功能 */ BufferedReader bufferedReader = new BufferedReader(reader); String line; while((line = bufferedReader.readLine()) != null) &#123; System.out.println(line); &#125; bufferedReader.close();&#125; Sockets ServerSocket:服务器端类 Socket:客户端类 服务器端和客户端通过InputStream和OutputStream进行输入输出Datagram DatagramSocket:通信类 DatagramPacket:数据包类NIOI/O与NIO最大的区别就是数据打包和传输的方式，I/O以流的方式处理数据,NIO以块的方式处理数据,弥补了I/O的不足,提供了高速的,面向块的IO NIO内容过多,此处不进行详细讲解 资料来源: CS-Notes]]></content>
      <categories>
        <category>技术</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>io</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot实战-cache]]></title>
    <url>%2Fposts%2Fc266cc15%2F</url>
    <content type="text"><![CDATA[文件配置 在日常的开发中,相信很多人都知道内存的速度要快于硬盘,而开发中瓶颈主要在数据库,所以需要相同的数据时，重复查询数据库会降低系统的性能,耗费大量的时间在数据库查询与方法调用上。 开发工具:idea jdK:1.8 开发环境:web环境 注释:本次测试使用jpa+mysql+lombok 引入所需依赖(*)： 123456789101112131415161718192021222324252627&lt;!-- cache 依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- jpa --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- web 启动类 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- mysql 数据库连接类 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- lombok --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; yml配置(properties内容一致,只是写法区别) spring.jpa.hibernate.ddl-auto: create:每次程序跑的时候，都会创建一个空的表。如果数据库中已经有这个表的话，会先删掉 update:第一次运行的时候，也会创建对应的数据表。但如果表里有数据，是不会删表，而是会保留 create-drop：应用停下来的时候，会把表删掉 validate：会验证实体类中的属性跟表结构是否一致，如果不一致的话会报错 none：默认的，什么都不做 123456789101112131415spring: ## 数据源 datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/student username: root password: 123 ## JPA jpa: hibernate: # ddl-auto: 设为 create 表示每次都重新建表 ddl-auto: update # 显示sql show-sql: true 继承接口JpaRepository-范型 12345678910package com.lsj.cache.dao;import com.lsj.cache.entity.Student;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.stereotype.Repository;@Repositorypublic interface StudentRepository extends JpaRepository&lt;Student, Integer&gt; &#123;&#125; entity –JPA用法此处不做详细描述 123456789101112131415161718192021222324package com.lsj.cache.entity;import lombok.AllArgsConstructor;import lombok.Getter;import lombok.NoArgsConstructor;import lombok.Setter;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;@Getter@Setter@AllArgsConstructor@NoArgsConstructor@Entity //声明为实体--可以指定tablepublic class Student &#123; @Id @GeneratedValue private Integer id; private String name; private Integer age;&#125; service 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.lsj.cache.service;import com.lsj.cache.dao.StudentRepository;import com.lsj.cache.entity.Student;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cache.annotation.CacheEvict;import org.springframework.cache.annotation.CachePut;import org.springframework.cache.annotation.Cacheable;import org.springframework.cache.annotation.EnableCaching;import org.springframework.stereotype.Service;@EnableCaching //开启缓存功能--也可以在启动类上开启@Servicepublic class StudentService &#123; //slf4j作为日志框架 private static final Logger LOGGER = LoggerFactory.getLogger(StudentService.class); @Autowired private StudentRepository studentRepository; //@CachePut 缓存新增的或更新的数据到缓存，其中缓存名称为 student 数据的 key 是 student 的 id @CachePut(value = "student",key = "#student.id") public Student saveStudent(Student student) &#123; Student stu = studentRepository.save(student); LOGGER.info("新增数据缓存到内存中"+student.getId()); return stu; &#125; @Cacheable(value = "student",key = "#id") public Student getStudentById(Integer id) &#123; Student stu = studentRepository.findById(id).get(); LOGGER.info("查询数据"+id); return stu; &#125; @CacheEvict(value="student") public void deleteStudentById(Integer id) &#123; studentRepository.deleteById(id); LOGGER.info("删除数据"+id); &#125;&#125; controller– 此处为了测试方便,统一使用的get请求,未遵循restful api风格 1234567891011121314151617181920212223242526272829303132333435package com.lsj.cache.controller;import com.lsj.cache.entity.Student;import com.lsj.cache.service.StudentService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping("/stu")public class StudentController &#123; @Autowired private StudentService studentService; //http://localhost:8080/stu/save?name=zs&amp;age=20 @GetMapping("/save") public Student saveStudent(Student stu) &#123; return studentService.saveStudent(stu); &#125; //http://localhost:8080/stu/able/1 @GetMapping("/able/&#123;id&#125;") public Student getStudentById(@PathVariable("id") Integer id) &#123; return studentService.getStudentById(id); &#125; //http://localhost:8080/stu/evict/1 @GetMapping("/evict/&#123;id&#125;") public void deleteStudentById(@PathVariable("id") Integer id) &#123; studentService.deleteStudentById(id); &#125;&#125; 缓存技术切换 EhCache: 12345&lt;!-- EhCache 依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache&lt;/artifactId&gt;&lt;/dependency&gt; Ehcache 所需配置文件 ehcache.xml 只需放在类路径（resource 目录）下，SpringBoot 会自动扫描，如： 1234&lt;?xml version="1.0" encoding="UTF-8"&gt;&lt;ehcache&gt; &lt;cache name="student" maxElementsInMmory="1000"&gt;&lt;ehcache&gt; SpringBoot 会自动配置 EhcacheManager 的 Bean 切换 Guava 123456&lt;!-- GuavaCache 依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;18.0&lt;/version&gt;&lt;/dependency&gt; 切换 RedisCache 12345&lt;!-- cache 依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt;&lt;/dependency&gt; 理论相关 spring支持的cacheManager CacheManager 描述 SimpleCacheManager 使用简单的 Collection 来存储缓存，主要用于测试 ConcurrentMapCacheManager 使用 ConcurrentMap 来存储缓存 NoOpCacheManager 仅测试用途，不会实际缓存数据 EhCacheCacheManager 使用 EhCache 作为缓存技术 GuavaCacheManager 使用 Google Guava 的 GuavaCache 作为缓存技术 HazelcastCacheManager 使用 Hazelcast 作为缓存技术 JCacheCacheManager 支持 JCache(JSR-107) 标准的实现作为缓存技术，如 ApacheCommonsJCS RedisCacheManager 使用 Redis 作为缓存技术 在使用以上任意一个实现的 CacheManager 的时候，需注册实现的 CacheManager 的 Bean，如： 12345@Beanpublic EhCacheCacheManager cacheManager(CacheManager ehCacheCacheManager)&#123; return new EhCacheCacheManager(ehCacheCacheManager);&#125; 缓存注解 注解 解释 @Cacheable 在方法执行前 Spring 先查看缓存中是否有数据，若有，则直接返回缓存数据；若无数据，调用方法将方法返回值放入缓存中 @CachePut 无论怎样，都会将方法的返回值放到缓存中。 @CacheEvict 将一条或多条数据从缓存中删除 @Caching 可以通过 @Caching 注解组合多个注解策略在一个方法上 @Cacheable、@CachePut、@CacheEvict 都有 value 属性，指定的是要使用的缓存名称；key 属性指定的是数据在缓存中存储的键。 开启声明式缓存支持 12345@Configuration@EnableCaching //开启缓存支持public class AppConfig&#123;&#125; SpringBoot 的支持 在 Spring 中使用缓存技术的关键是配置 CacheManager ，而 SpringBoot 为我们配置了多个 CacheManager 的实现。 它的自动配置放在 org.springframework.boot.autoconfigure.cache 包中。 在不做任何配置的情况下，默认使用的是 SimpleCacheConfiguration ，即使用 ConcurrentMapCacheManager。SpringBoot 支持以前缀来配置缓存。例如： 1234567spring.cache.type= # 可选 generic、ehcache、hazelcast、infinispan、jcache、redis、guava、simple、nonespring.cache.cache-names= # 程序启动时创建的缓存名称spring.cache.ehcache.config= # ehcache 配置文件的地址spring.cache.hazelcast.config= # hazelcast配置文件的地址spring.cache.infinispan.config= # infinispan配置文件的地址spring.cache.jcache.config= # jcache配置文件的地址spring.cache.jcache.provider= # 当多个 jcache 实现在类路径的时候，指定 jcache 实现]]></content>
      <categories>
        <category>技术</category>
        <category>Spring-Boot</category>
      </categories>
      <tags>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker上手]]></title>
    <url>%2Fposts%2F8675a597%2F</url>
    <content type="text"><![CDATA[docker安装资料参考： 安装环境-ubuntu 18.04(终端) 1.sudo apt install docker.io 2.sudo systemctl start docker 3.sudo systemctl enable docker 查看docker是否安装完成 docker -v docker使用 例：docker search mysql –实际相当于在https://hub.docker.com/进行查询 docker下载库(加name即可) docker pull mysql – 默认下载latest版本 docker换源 1.修改json文件：vi /etc/docker/daemon.json-加入如下代码{ “registry-mirrors” : [“https://docker.mirrors.ustc.edu.cn&quot;]}2.重启服务sudo service docker restart||如果出现以下问题,可通过重启服务解决Error response from daemon: Get https://registry-1.docker.io/v2/: dial tcp: lookup registry-1.docker.io: no such host 查看docker镜像 docker images 下载指定版本镜像(版本可以在网站查找) docker pull mysql:5.5 镜像删除 docker rmi image-id 容器安装软件镜像(qq安装程序)-运行镜像-产生一个新容器(正在运行的软件) 步骤： 1.搜索镜像 docker search tomcat 2.拉取镜像 docker pull tomcat 3.根据镜像启动容器 docker run –name container-name -d image-name 如:docker run –mytomcat -d tomcat –name:自定义容器名 -d:后台运行 image-name:指定镜像模板 4.查看运行中的容器 docker ps 5.docker停止 docker stop container_id 6.查看所有的容器 docker ps -a 7.删除容器（rmi是删除镜像,rm是删除容器） docker rm contaner_id 8.端口映射(-p) -8888映射8080— 需要关闭防火墙服务 docker run -d -p 8888:8080 tomcat 9.查看防火墙状态 sudo ufw status 10.容器日志 docker logs container-name/container-id 更多命令查看: https://docs.docker.com/engine/reference/commandline/docker docker安装mysql 具体操作参考dockerhub 1.docker pull mysql 2.$ docker run –name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag]]></content>
      <categories>
        <category>技术</category>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hugo博客搭建]]></title>
    <url>%2Fposts%2Fccb0aaa5%2F</url>
    <content type="text"><![CDATA[hugo官方资料参考 终端（使用linux终端-ubuntu18.04） 安装hugo(macos使用brew) –因为apt-get下载版本太低,所以使用snap 1snap install hugo 检查hugo版本 1hugo version 创建博客 1hugo new site hugoblog 切换到blog目录 1cd hugoblog hugo主题下载:hugo主题 示例: 12$ cd [path] //切换到hugo博客根目录$ git clone https://github.com/vaga/hugo-theme-m10c.git themes/m10c //主题会存放在themes目录下 启动服务 1hugo server -t m10c --buildDrafts //指定m10c主题 创建文章(md) 1hugo new post/hugo搭建.md //创建后再次启动服务即可 github部署 创建github仓库 1取名为:helloworld-liushijie.github.io 将个人博客部署到远端服务器 basic1hugo --theme=m10c --baseUrl=&quot;https://helloworld-liushijie.github.io/&quot; --buildDrafts 部署成功后会生成public文件夹,切换到public文件夹,将public文件夹传到github basic12345$ git init$ git add . //全部加入$ git commit -m &quot;hugo blog commit&quot;$ git remote add origin https://github.com/helloworld-liushijie/helloworld-liushijie.github.io.git$ git push -u origin master //推到远端(输入username pwd)]]></content>
      <categories>
        <category>技术</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hugo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[var,let,const关键字]]></title>
    <url>%2Fposts%2F2c19b075%2F</url>
    <content type="text"><![CDATA[相信知道es6的大家都或多或少的知道es6中新增了let,const关键字用于声明标识符,那么他们之间具体有什么区别呢? let声明变量,会在当前作用域形成代码块 const用于声明常量,所谓常量就是物理指针不可以更改的变量1234567891011//let,const只在块级作用域有效&#123; let i = 10;&#125;console.log(i);//报错: i is not defined//var定义的变量，没有块的概念，可以跨块访问，不能跨函数访问&#123; var i = 10;&#125;console.log(i);//10 var var声明的变量会存在变量提升1234567console.log(a);//undefinedvar a = 10;实际等同于：var a;console.log(a);a = 10; 所以在使用时，注意先进行变量声明 1234567891011var x = 1;if (x === 1) &#123; var x = 2; console.log(x); // expected output: 2&#125;console.log(x);// expected output: 2 More info: var let接下来介绍下 let 的特性，使用 let 声明的变量，只能在当前代码块中访问和使用，有些类似于函数作用域，但是它又有几点不同的地方 let 声明变量，变量不会被提升。 12345function fn1()&#123; console.log(a); let a = 1;&#125;fn1(); // 报错 for 循环中 使用let 定义变量，只在for的循环周期内可以使用 12345678910111213for(var i = 0;i &lt; 5;i++) &#123; setTimeout(function() &#123; console.log(i) &#125;, 1000);&#125;//结果：5个5for(let i = 0;i &lt; 5;i++) &#123; setTimeout(function() &#123; console.log(i) &#125;, 1000);&#125;//结果：0，1，2，3，4 constconst除了不能改变物理指针的特性外,其他特性和let一样 使用const必须初始化 12345let i;console.log(i);//undefinedconst i;console.log(i);// Missing initializer in const declaration 当声明复杂数据类型的时候，物理指针不可以改变，但是可以改变数据内的属性值，以及可以给数据添加新属性等操作。 12345const person = &#123; name:'mary'&#125;person.name = "jack";console.log(person);//'&#123;name:'jack'&#125;']]></content>
      <categories>
        <category>技术</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
</search>
