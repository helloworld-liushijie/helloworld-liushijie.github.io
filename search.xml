<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[理解css中的BFC]]></title>
    <url>%2Fposts%2F82f3f45e%2F</url>
    <content type="text"><![CDATA[什么是BFC BFC:块格式化上下文 Web页面的可视化CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域 BFC作用 BFC用于形成一个完全独立的空间,让空间的子元素不会影响到外面的布局 BFC使用触发条件 此处只列举最常用的四种bfc触发规则,更多触发规则可以查看文章末尾的mdn链接,此处不讨论flex,grid解决相关问题 float不为none position不为relative或static overflow为auto scroll或hidden display为table-cell或inline-block 作用解决浮动元素令父元素高度塌陷问题 出现原因分析 原因: (子元素全是float元素 且 父元素没有设置高度) 子元素使用float,浮动的子元素脱离文档流,父元素检测不到子元素的存在无法被撑开,导致父元素高度塌陷,后面布局出现混乱 123456789101112131415161718192021222324252627282930&lt;main class="container"&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/main&gt;&lt;!-- 为了看起来直观,就直接把less放这儿了 --&gt;.container &#123; padding: 10px; border: solid 1px red; div &#123; float: left; width: 100px; height: 100px; &amp;:nth-of-type(1) &#123; background-color: sandybrown; &#125; &amp;:nth-of-type(2) &#123; background-color: chartreuse; &#125; &amp;:nth-of-type(3) &#123; background-color: cyan; &#125; &amp;:nth-of-type(4) &#123; background-color: blue; &#125; &#125;&#125;&lt;/less&gt; 解决方案: overflow:hidden; display:table-cell; display:block; position:fixed; position:absolute; … 当以上布局方案无法设置以上属性,可以使用如下方案: 让父元素也浮动起来(父元素和子元素一起脱离文档流) fload:left=&gt;会影响父元素之后的排列引发其他问题 给父元素设置固定高度=&gt;只适用于已经子级元素高度的情况下使用,不灵活且难以维护 在浮动的子元素最后面增加一个空标签(没有闭合的标签,如&lt;br/&gt;与&lt;img/&gt;),设置{clear:both}来清除浮动,会增加无意义的标签,不利于维护 为浮动的最后一个元素设置伪元素(在父元素设置::after) =&gt; 与方案三原理相同,after需要设置为块级元素 .container::after { ​ content: ‘’; ​ display: block; ​ clear: both; } 解决自适应的问题 出现原因分析 在通过浮动实现两栏自适应布局时(左边宽度固定,右边自适应) =&gt; 当右侧文字高度超出左侧高度时,会出现右侧文字出现在左侧的问题 123456789101112131415161718192021222324&lt;main class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt; &lt;!-- 这儿使用的是Loream乱数假文 --&gt; &lt;/div&gt;&lt;/main&gt;&lt;!-- 为了看起来直观,就直接把less放这儿了 --&gt;&lt;less&gt; .container &#123; div &#123; &amp;:nth-of-type(1) &#123; height: 50px; float: left; width: 200px; background-color: sandybrown; &#125; &amp;:nth-of-type(2) &#123; height: 500px; background-color: pink; &#125; &#125; &#125;&lt;/less&gt; 解决方案 左边左浮动,右边设置margin-let: 100px 1234567.left &#123; float: left; width: 200px;&#125;.right &#123; margin-left: 200px;&#125; 左边绝对定位,右边设置margin-let: 200px 1234567.left &#123; &lt;!-- top/left/bottom/right自行设置 --&gt; position: absolute;&#125;.right &#123; margin-left: 200px;&#125; 右侧元素设置顶线与右线位置为0,左线为200px 123456789.left &#123; position: absolute;&#125;.right &#123; position: absolute; top: 0; right: 0; left: 200px;&#125; 解决外边距垂直方向重合问题 出现原因分析 当两个块级元素分别设置margin-bottom:20px,margin-top:25px=&gt;此时实际两个块级边框距离为最大值(25px) 1234567891011121314151617&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;less&gt; p &#123; width: 100px; height: 100px; &amp;:nth-of-type(1) &#123; margin-bottom: 20px; background-color: pink; &#125; &amp;:nth-of-type(1) &#123; margin-bottom: 25px; background-color: cyan; &#125; &#125;&lt;/less&gt; 解决方案 其中一个p元素外面包裹一层父元素 12345678910111213141516171819202122&lt;p&gt;&lt;/p&gt;&lt;div&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;less&gt; p &#123; width: 100px; height: 100px; margin-bottom: 20px; background-color: pink; &#125; div &#123; overflow: hidden; p &#123; margin-top: 20px; width: 100px; height: 100px; background-color: cyan; &#125; &#125;&lt;/less&gt; 用padding代替margin(这个就不需要写代码) mdn bfc]]></content>
      <categories>
        <category>技术</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>front end</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue入门]]></title>
    <url>%2Fposts%2F5d8ad28b%2F</url>
    <content type="text"><![CDATA[vue引用12345&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue"&gt;&lt;/script&gt; vue基本代码结构123456789101112&lt;div id="app"&gt; &#123;&#123;msg&#125;&#125;&lt;/div&gt;&lt;script&gt;var vm = new Vue(&#123; //非常重要,如果不在此区域定义的属性不会生效 el: '#app', data: &#123; msg: 'LOGIN IN' &#125;&#125;)&lt;/script&gt; v-text,v-cloak,v-html123456789101112131415&lt;div id="app"&gt; &lt;div v-cloak&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt; &lt;div v-text="msg"&gt;&lt;/div&gt; &lt;div v-html="msg2"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var vue = new Vue(&#123; el: '#app', data : &#123; msg: 'Hello World', msg2: '&lt;h2&gt;Hi&lt;/h2&gt;' &#125; &#125;)&lt;/script&gt; 三者区别说明: v-cloak:用于在网速较慢的时候,vue还未完成渲染,会显示,此属性用于对进行隐藏 v-text:作用与相同,但是在网速较慢的时候,直接不进行显示 v-html:可以对html进行渲染 v-bind数据绑定1234567891011&lt;input type="button" value="按钮" v-bind:title="title"/&gt;&lt;!-- 简写 :title等同于v-bind:title,v-bind里面可以写合法的js表达式 --&gt;&lt;input type="button" value="按钮" :title="title + '123'"/&gt;&lt;script&gt; var vue = new Vue(&#123; el: '#app', data : &#123; title: 'Title' &#125; &#125;)&lt;/script&gt; v-on事件绑定1234567891011121314151617&lt;div id="app"&gt; &lt;!-- v-on:后面跟事件类型,如click,keyups --&gt; &lt;input type="button" value="按钮" v-on:click="show"/&gt; &lt;!-- 缩写@click --&gt; &lt;input type="button" value="按钮" @click="show"/&gt;&lt;/div&gt;&lt;script&gt; var vue = new Vue(&#123; el: '#app', methods: &#123; show:function() &#123; alert("hello"); &#125; &#125; &#125;)&lt;/script&gt; 跑马灯效果实现 需求:点击”浪起来”实现跑马灯效果,点击”低调”停止跑马灯效果 1234567891011121314151617181920212223242526272829&lt;div id="app"&gt; &lt;input type="button" value="浪起来" @click="lang"/&gt; &lt;input type="button" value="低调" @click="stop"/&gt; &lt;h4&gt;&#123;&#123;msg&#125;&#125;&lt;/h4&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; msg: '猥琐发育,别浪~~', intervalId: null &#125;, methods: &#123; lang() &#123; if(this.intervalId != null) return; this.intervalId = setInterval(() =&gt; &#123; var start = this.msg.charAt(0); var end = this.msg.substr(1); this.msg = end + start; &#125;,400) &#125;, stop() &#123; clearInterval(this.intervalId); this.intervalId = null; &#125; &#125; &#125;)&lt;/script&gt; 事件修饰符 .stop 阻止冒泡 .prevent 阻止默认事件 .capture 添加事件侦听器时使用事件捕获模式 .self 只当事件在该元素本身(比如不是子元素)触发时触发回调 .once 事件只触发一次 12345678910111213141516171819202122232425&lt;!-- 事件修饰符可以合并使用:如@click.stop.prevent --&gt;&lt;div id="app"&gt; &lt;div id="area" @click="divClick" style="background: darkcyan"&gt; &lt;!-- 阻止冒泡事件 --&gt; &lt;input type="button" value="按钮" @click.stop="btnClick"/&gt; &lt;a href="https://www.baidu.com/" @click.prevent="linkClick"&gt;阻止默认行为&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', methods: &#123; divClick() &#123; alert("div_click"); &#125;, btnClick() &#123; alert("btn_click"); &#125;, linkClick() &#123; alert("触发点击事件") &#125; &#125; &#125;)&lt;/script&gt; v-model实现双向数据绑定 实现V修改同步到M,M修改同步到V,v-model只能运用在表单元素中,如下 &lt;input(radio,text,address,email…)&gt; select checkbox textarea 1234567891011121314&lt;div id="app"&gt; &lt;!-- 修改input,span内容也会改变 --&gt; &lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt;&lt;br/&gt; &lt;input type="text" v-model="msg"&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; msg: 'this is a msg' &#125; &#125;)&lt;/script&gt; v-model实现简易计算器效果123456789101112131415161718192021222324252627282930&lt;div id="app"&gt; &lt;input type="text" v-model="n1"/&gt; &lt;select v-model="opt"&gt; &lt;option value="+"&gt;+&lt;/option&gt; &lt;option value="-"&gt;-&lt;/option&gt; &lt;option value="*"&gt;*&lt;/option&gt; &lt;option value="/"&gt;/&lt;/option&gt; &lt;/select&gt; &lt;input type="text" v-model="n2"/&gt; &lt;button @click="calc"&gt;=&lt;/button&gt; &lt;input type="text" v-model="result"/&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; n1: 0, n2: 0, result: 0, opt: '-' &#125;, methods: &#123; calc() &#123; //只是demo,不要过于纠结细节 var codeStr = 'this.n1' + this.opt + this.n2; this.result = eval(codeStr); &#125; &#125;, &#125;)&lt;/script&gt; 在vue中使用样式使用class样式 数组 1&lt;h1 :class="['red','thin']"&gt;this is a eval h1&lt;/h1&gt; 数组中使用三元表达式 1&lt;h1 :class="['red','thin',isactive?'active':'']"&gt;this is a eval h1&lt;/h1&gt; 数组中嵌套对象 1&lt;h1 :class="['red','thin',&#123;'active':isactive&#125;]"&gt;this is a eval h1&lt;/h1&gt; 直接使用对象 1&lt;h1 :class="&#123;red:true,italic:true,active:true,thin:true&#125;"&gt;this is a eval h1&lt;/h1&gt; 使用内联样式 直接在元素上通过:style的形式,书写样式对象 1&lt;h1 :style="&#123;color:'red','font-size':'40px'&#125;"&gt;this is a eval h1&lt;/h1&gt; 将样式对象,定义到data中,并直接引用到:style中 在data上定义样式(注意:如果属性存在’-‘,必须添加单引号) 123data: &#123; h1StyleObj: &#123;color:'red','font-size': '40px','font-weight': '200'&#125;&#125; 在元素中,通过属性绑定的形式,将样式对象应用到元素中: 1&lt;h1 :style="h1StyleObj"&gt;this is a eval h1&lt;/h1&gt; 在:style中通过数组,引用多个data上的样式对象 在data上定义样式(注意:如果属性存在’-‘,必须添加单引号) 1234data: &#123; h1StyleObj: &#123;color:'red','font-size': '40px','font-weight': '200'&#125;, h1StyleObj2: &#123;font-style: 'italic'&#125;&#125; 在元素中,通过属性绑定的形式,将样式对象应用到元素中 1&lt;h1 :style="[h1StyleObj,h1StyleObj2]"&gt;this is a eval h1&lt;/h1&gt; vue指令v-for与key属性 2.20+的版本中,当在组件中使用v-for时,key现在是必须的 当Vue.js用v-for正在更新已渲染过的元素列表时,它默认用”就地复用”策略,如果数据项的顺序被改变,Vue将不是移动DOM元素来匹配数据项的顺序,而是简单复用此处每个元素,并且确保它在特定索引下显示已被渲染过的每个元素。 为了给Vue一个提示,以便它能追踪每个节点的身份,从而复用和重新排序现有元素,你需要单独为每项提供一个唯一key属性 迭代数组 123&lt;ul&gt; &lt;li v-for="(item,i) in list"&gt;索引:&#123;&#123;i&#125; --- 姓名:&#123;&#123;item.name&#125;&#125; --- 年龄:&#123;&#123;item.age&#125;&#125;&#125;&lt;/li&gt;&lt;/ul&gt; 迭代对象中的属性(顺序为:值,键,索引) 12&lt;!-- 循环遍历对象身上的属性 --&gt;&lt;div v-for="(val,ke,i) in userInfo"&gt;&#123;&#123;&#123;val&#125;&#125; --- &#123;&#123;key&#125;&#125; --- &#123;&#123;i&#125;&#125;&#125;&lt;/div&gt; 迭代数字(i从1开始) 1&lt;p v-for="i in 10"&gt;&#123;&#123;i&#125;&#125;&lt;/p&gt; v-if和v-show v-if每次都会重新删除或创建元素;v-for每次不会重新进行DOM的删除和创建操作,只是切换display:none样式; v-if有较高的切换性能消耗,v-for有较高的初始渲染消耗;如果元素涉及到频繁的切换,最好不要使用v-if 12345678910111213&lt;div id="app"&gt; &lt;input type="button" @click="flag=!flag" value="切换"&gt; &lt;h3 v-if="flag"&gt;这是v-if控制的元素&lt;/h3&gt; &lt;h3 v-show="flag"&gt;这是v-show控制的元素&lt;/h3&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; flag: true &#125; &#125;)&lt;/script&gt; 案例: 使用vue实现品牌新增,删除以及关键字搜索和时间处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;div id="app"&gt; &lt;div class="panel panel-primary"&gt; &lt;div class="panel-heading"&gt; &lt;h3 class="panel-title"&gt;添加品牌&lt;/h3&gt; &lt;/div&gt; &lt;div class="panel-body form-inline"&gt; &lt;label&gt; id: &lt;input type="text" class="form-control" v-model="id"&gt; &lt;/label&gt; &lt;label&gt; name: &lt;input type="text" class="form-control" v-model="name"&gt; &lt;/label&gt; &lt;input type="button" value="添加" class="btn btn-primary" @click="add"&gt; &lt;label&gt; 搜索名称关键字 &lt;!-- 在vue中的所有指令,在调用的时候都以v-开头 --&gt; &lt;input type="text" class="form-control" v-model="keywords"&gt; &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;table class="table table-hover table-bordered table-striped"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;name&lt;/th&gt; &lt;th&gt;ctime&lt;/th&gt; &lt;th&gt;operation&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for="item in search(keywords)" :key="item.id"&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime | dateFormat('yyyy-MM-dd')&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="#" @click.prevent="del(item.id)"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;&lt;script&gt; //全局过滤器 Vue.filter('dateFormat',function(dateStr,pattern = '') &#123; //根据给定字符串获取特定时间 var dt = new Date(dateStr) //yyyy-mm-dd var y = dt.getFullYear() var m = dt.getMonth() + 1 var d = dt.getDate() if(pattern &amp;&amp; pattern.toLowerCase() == 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;` &#125; else &#123; var hh = dt.getHours() //padStart:开始填充;padEnd():末尾填充(如两位填充数字1: 01 和 10) var mm = (dt.getMinutes()).toString().padStart(2,'0') var ss = (dt.getSeconds()).toString().padStart(2,'0') return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;` &#125; &#125;) var vm = new Vue(&#123; el: '#app', data: &#123; id:null, name:null, keywords:'', list: [ &#123;id : 1,name: '奔驰',ctime: new Date()&#125;, &#123;id : 2,name: '宝马',ctime: new Date()&#125;, &#123;id : 3,name: '保时捷',ctime: new Date()&#125; ] &#125;, methods: &#123; add() &#123; var car = &#123;id: this.id,name: this.name,ctime: new Date()&#125;; this.list.push(car); this.id = this.name = null; &#125;, del(id) &#123; // this.list.some((item,i) =&gt; &#123; // if(item.id == id) &#123; // this.list.splice(i,1); // return true; // &#125; // &#125;) var index = this.list.findIndex(item =&gt; &#123; if(item.id == id) &#123; return true; &#125; &#125;) this.list.splice(index,1); &#125;, search(keywords) &#123; //"测试".indexOf('')等于0 // var newList = []; // this.list.forEach(item =&gt; &#123; // if(item.name.indexOf(keywords) != -1) &#123; // newList.push(item); // &#125; // &#125;) // return newList; return this.list.filter(item =&gt; &#123; if(item.name.includes(keywords)) &#123; return true; &#125; &#125;) &#125; &#125;, filters: &#123; //定义私有过滤器【过滤器名称和处理函数】 //如果同名, dateFormat:function(dateStr,pattern) &#123; return "私有过滤器" &#125; &#125; &#125;)&lt;/script&gt; vue-devtools安装 推荐翻墙安装,搜索Vue.js devtools 注意事项: vue扩展程序需要勾选允许访问文件网址和收集各项错误;同时引入的vue.js不能使用min.js 过滤器 vue.js允许自定义过滤器,可被用作一些常见文本格式化.过滤器可以用在两个地方:mustache插值和v-bind表达式.过滤器应该被添加在js表达式的尾部,由”管道”符指示 私有过滤器 过滤器调用: Vue.filter(‘过滤器名称’,function(){}) //过滤器中的function,第一个参数已经规定死了,永远都是过滤器管道符前面传递过来的数据 html元素 1&lt;td&gt;&#123;&#123;item.ctime | dataFormat('yyyy-mm-dd')&#125;&#125;&lt;/td&gt; 私有filter定义方式 12345filters: &#123; dataFormat(input,pattern = '') &#123; ... &#125;&#125; 替换’单纯’为’邪恶’ 1234567891011121314151617&lt;div id="app"&gt; &lt;p&gt; &#123;&#123;msg | msgFormat('邪恶') | str&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; Vue.filter('msgFormat',function(msg,arg) &#123; return msg.replace(/单纯/g,arg); &#125;) Vue.filter('str',function(msg) &#123; return msg+"---"; &#125;) var vm = new Vue(&#123; el: '#app', data: &#123; msg: '曾经,我也是一个单纯的少年,单纯的我,傻傻的问,谁是世界上最单纯的男人' &#125; &#125;)&lt;/script&gt; 自定义按键修饰符 1.x中自定义键盘修饰符(了解不推荐) 1Vue.directive('on').keyCodes.f2 = 113; 2.x中自定义键盘修饰符 通过Vue.config.keyCodes.名称 = 按键值来自定义按键修饰符的别名 1Vue.config.keyCodes.f2 = 113; 使用自定义的按键修饰符 1&lt;input type="text" v-model="name" @keyup.f2="add"&gt; 自定义指令 参数1：指令的名称,在定义的时候不需要加v-前缀,在调用的时候,必须加上v-前缀 参数2：一个对象,对象身上有一些指令相关的函数,函数可以在特定的阶段,执行相关的操作 使用Vue.directive()定义全局指令 123456789101112131415161718192021222324252627282930313233343536&lt;input id="search" type="text" class="form-control" v-model="keywords" v-focus v-color="'blue'"&gt;&lt;script&gt; //自动获取焦点 Vue.directive('focus',&#123; //在每个函数中,第一个参数永远是el,表示被绑定了指令的那个元素,这个el参数是一个原生js对象 bind:function()&#123;&#125;, //每当指令绑定在元素上的时候,会立即执行这个bind函数,只执行一次 inserted:function(el)&#123; el.focus(); &#125;,//元素插入到dom中的时候会执行inserted函数,触发一次 updated:function()&#123;&#125;//当VNode更新的时候,会执行updated,可能会触发多次 &#125;); //写法一:全局 //修改字体颜色 Vue.directive('color',&#123; bind: function(el,expression) &#123; el.style.color = binding.value; console.log(binding.name);//color console.log(binding.value);//blue console.log(binding.expression);//'blue' &#125; &#125;) //写法二:私有 var vue = new Vue(&#123; el: '#app', directives: &#123; 'color': &#123; bind: function(el,binding) &#123; el.style.color = binding.value; ... &#125; &#125; &#125; &#125;)&lt;/script&gt; 函数简写 在很多时候，你可能想在 bind 和 update 时触发相同行为，而不关心其它的钩子。比如这样写: 123Vue.directive('color-swatch', function (el, binding) &#123; el.style.backgroundColor = binding.value&#125;) vue实例的生命周期 什么是生命周期:从vue实例创建,运行到销毁期间,总是伴随着各种各样的事件,这些事件统称为生命周期 生命周期钩子: 生命周期事件的别名 主要的生命周期函数分类 创建期间的生命周期函数 beforeCreate: 实例刚在内存中被创建出来,此时,还没有初始化好data 和 methods属性 created: 实例已经在内存中创建ok,此时data和Methods已经创建ok,此时还没有开始编译模板 beforeMount: 此时已经完成模板的编译,但是还没有挂在到页面中 mounted: 此时,已经将编译好的模板,挂在到了页面指定的容器中显示 运行期间的生命周期函数 beforeUpdate: 状态更新之前执行此函数,此时data中的状态值是最新的,但是界面上显示的数据还是旧的,因为此时还没有开始渲染DOM节点 updated: 实例更新完毕之后调用此函数,此时data中的状态值和页面上显示的数据,都已经完成了更新,界面已经被重新渲染好了 销毁期间的生命周期 beforeDestory: 实例销毁之前调用,在这一步,实例仍然完全可用 destoryedL Vue实例销毁后调用,调用后,vue实例指示的所有东西都会解除绑定,所有的事件监听器都会移除,所有的子实例也会被销毁 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;div id="app"&gt; &lt;input type="button" value="触发change" @click="msg='this is not a msg'"&gt; &lt;h3 id="h3"&gt;&#123;&#123;msg&#125;&#125;&lt;/h3&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; msg: 'this is a msg' &#125;, methods: &#123; show() &#123; console.log("this is a function") &#125; &#125;, //实例化周期 beforeCreate() &#123; // first life cycle function //在beforeCreate生命周期函数执行的时候,data和methos中的数据都还没有初始化 console.log(this.msg)//undefined &#125;, created() &#123; //second life cycle function //如果要调用methods中的方法,或操作data中的数据,最早只能在created中操作 console.log(this.msg)//this is a msg &#125;, beforeMount() &#123; //third life cycle function //模板已经在内存中编辑完成,尚未把模板渲染到页面中去,页面中的元素还未替换过来 console.log(document.getElementById("h3").innerText)//&#123;&#123;msg&#125;&#125; &#125;, mounted() &#123; //fourth life cycle function //内存中的模板,已经真实的挂载到了页面中,用户已经可以看到渲染好的页面("实例创建"的最后一个生命周期函数) console.log(document.getElementById("h3").innerText)//this is a msg &#125;, //运行中周期 beforeUpdate() &#123; //数据被改变触发,此时页面中显示的数据还未与最新数据同步,data数据已经最新 console.log(document.getElementById("h3").innerText)//页面数据:this is a msg console.log(this.msg)//data中的msg数据:this is not a msg &#125;, updated() &#123; //此时,页面和data数据已经保持同步,都是最新的 console.log(document.getElementById("h3").innerText)//页面数据:this is not a msg console.log(this.msg)//data中的msg数据:this is not a msg &#125;, &#125;)&lt;/script&gt; vue-resource实现get,post,jsonp请求 除了vue-resource外,还可以使用axios实现数据的请求 用于测试请求的api(有兴趣的小伙伴可以自己写api接口测试) get请求: https://jsonplaceholder.typicode.com/users post请求: https://jsonplaceholder.typicode.com/users jsonp请求: https://jsonplaceholder.typicode.com/users vue-resource github docs 123456789101112131415161718192021222324252627282930313233343536&lt;!-- 依赖于vue.js --&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue-resource@1.5.1"&gt;&lt;/script&gt;&lt;div id="app"&gt; &lt;input type="button" value="get请求" @click="getInfo"&gt; &lt;input type="button" value="post请求" @click="postInfo"&gt; &lt;input type="button" value="jsonp请求" @click="jsonpInfo"&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; getInfo() &#123; var get_url = 'https://jsonplaceholder.typicode.com/users' this.$http.get(get_url).then(response =&gt; &#123; console.log(response.body) &#125;) &#125;, postInfo() &#123; //emulateJSON:Send request body as application/x-www-form-urlencoded content type var post_url = 'https://jsonplaceholder.typicode.com/users' this.$http.post(post_url,&#123;&#125;,&#123;emulateJSON:true&#125;).then(response =&gt; &#123; console.log(response.body) &#125;) &#125;, jsonpInfo() &#123; var jsonp_url = "https://jsonplaceholder.typicode.com/users" this.$http.jsonp(jsonp_url).then(response =&gt; &#123; console.log(response.body) &#125;) &#125; &#125; &#125;)&lt;/script&gt; vue-resource结合node手写jsonp 前提:已经安装了node.js,参考node.js安装配置 vscode本地服务器启动: 下载Live Server插件&gt; open with live server nodejs app启动: vscode &gt; debug &gt; start debugging JSONP的实现原理 由于浏览器的安全限制,不允许ajax访问协议不同,域名不同,端口不同的数据接口,浏览器认为这种访问不安全 可以通过动态创建script标签的形式,把script标签的src属性,指向数据接口的地址,因为script标签不存在跨域限制,这种数据获取方式,称作jsonp(根据jsonp的实现原理,jsonp只支持get请求) 具体实现过程 先在客户端定义一个回调方法,预定义对数据的操作 再把这个回调方法的名称,通过url传参的形式,提交到服务器的数据接口 服务器数据接口组织好要发送给客户端的数据,再拿到客户端传过来的回调方法命名成,拼接出一个调用这个方法的字符串,发送给客户端去解析执行 客户端拿到服务器返回的字符串之后,当作script脚本去解析执行,这样就能够拿到jsonp的数据了 client_jsonp.html 1234567&lt;script&gt; function showInfo(data) &#123; console.log(data) //&#123;name: "zhangsan", age: 18, gender: "male"&#125; &#125;&lt;/script&gt;&lt;script src="http://127.0.0.1:3000/getscript?callback=showInfo"&gt;&lt;/script&gt; node_module/app.js 1234567891011121314151617181920212223242526272829303132//导入http内置模板const http = require('http')//这个核心模块,能够帮我们解析url地址,从而拿到pathname queryconst url_module = require('url')//创建一个http服务器const server = http.createServer()//监听http服务器的request请求server.on('request',function(req,res) &#123; //const url = req.url const &#123;pathname:url,query&#125; = url_module.parse(req.url,true) if(url == '/getscript') &#123; //拼接一个合法的js脚本 //var scriptStr = 'show()' var data = &#123; name: 'zhangsan', age: 18, gender: 'male' &#125; var scriptStr = `$&#123;query.callback&#125;($&#123;JSON.stringify(data)&#125;)` //res.end发送给客户端,客户端拿到后当作js代码解析执行 res.end(scriptStr) &#125; else &#123; res.end('404') &#125;&#125;)//指定端口号并启动服务器监听server.listen(3000,function() &#123; console.log('server listen at http://127.0.0.1:3000')&#125;) 此时http://127.0.0.1:5500/client_jsonp.html (live server默认5500端口),控制台此时输出 ok 案例:vue-resource实现品牌列表改造前端代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;vue resource改造品牌列表&lt;/title&gt; &lt;link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue-resource@1.5.1"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;div class="panel panel-success"&gt; &lt;div class="panel-heading"&gt; &lt;h3 class="panel-title"&gt;添加品牌&lt;/h3&gt; &lt;/div&gt; &lt;div class="panel-body form-inline"&gt; &lt;label&gt; NAME &lt;input type="text" class="form-control" v-model="name" &gt; &lt;/label&gt; &lt;input type="button" class="btn btn-success" value="新增" @click="add" &gt; &lt;input type="button" class="btn btn-success" value="获取品牌列表" &gt; &lt;/div&gt; &lt;/div&gt; &lt;table class="table table-bordered table-hover table-striped"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;name&lt;/th&gt; &lt;th&gt;ctime&lt;/th&gt; &lt;th&gt;operation&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for="item in list" :key="item.id"&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.cname&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="" @click.prevent="remove(item.id)"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;script&gt; const global_url = "http://127.0.0.1:8080"; var vm = new Vue(&#123; el: '#app', data: &#123; name:'', list: &#123;&#125; &#125;, created() &#123; this.$http.get(`$&#123;global_url&#125;/api/getprodList`).then(response =&gt; &#123; var data = response.body if(status == 0) &#123; this.list = data.msg &#125; else &#123; alert("数据获取失败") &#125; &#125;) &#125;, methods: &#123; add() &#123; this.$http.post(`$&#123;global_url&#125;/api/addproduct`,&#123;name:this.name&#125;,&#123;emulateJSON:true&#125;).then(response =&gt; &#123; var data = response.body if(status == 0) &#123; this.list = data.msg this.name = null &#125; else &#123; alert("添加失败") &#125; &#125;) &#125;, remove(id) &#123; //this.list.splice(this.list.findIndex(item =&gt; item.id === id), 1) this.$http.delete(`$&#123;global_url&#125;/api/removeproduct/$&#123;id&#125;`).then(response =&gt; &#123; var data = response.body if(status == 0) &#123; this.list = data.msg &#125; else &#123; alert("删除失败") &#125; &#125;) &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 因为视频的api链接失效了,所以自己按照api文档手写了一个(凑合使用),熟悉后端的可以自己写一个 后端api代码 vue-resource全局配置数据接口的根域名12345//Note that for the root option to work, the path of the request must be relative. This will use this the root option: Vue.http.get('someUrl') while this will not: Vue.http.get('/someUrl').Vue.http.options.root = '/root';//such as: api/getprodList不能写成/api/getprodList =&gt; 不能使用绝对路径Vue.http.options.root = 'http://127.0.0.1:8080'this.$http.get(`api/getprodList`).then(response =&gt; &#123;&#125;) 全局启用emulateJSON1Vue.http.options.emulateJSON = true; vue动画 动画能够提高用户的体验,帮助用户更好的理解页面中的功能 自定义动画12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;style&gt; /* v-enter 是进入之前,元素的起始状态,还没开始进入;v-leave-to: 是动画离开之后,离开的终止状态 */ .v-enter, .v-leave-to &#123; opacity: 0; transform: translateX(200px); &#125; /* v-enter-active:入场动画的时间段;v-leave-active:离场动画的时间段 */ .v-enter-active, .v-leave-active &#123; transition: all .8s ease; &#125; .my-enter, .my-leave-to &#123; opacity: 0; transform: translateY(200px); &#125; /* v-enter-active:入场动画的时间段;v-leave-active:离场动画的时间段 */ .my-enter-active, .my-leave-active &#123; transition: all .8s ease; &#125;&lt;/style&gt;&lt;div id="app"&gt; &lt;input type="button" value="toggle" @click="flag = !flag"&gt;&lt;br/&gt; &lt;input type="button" value="toggle" @click="flag1 = !flag1"&gt; &lt;!-- 需求: 点击按钮,让h3显示,再点击让h3隐藏 --&gt; &lt;!-- 使用transition元素(vue官方提供),把需要控制的元素包裹起来 --&gt; &lt;transition&gt; &lt;h3 v-if="flag"&gt;this is h3&lt;/h3&gt; &lt;/transition&gt; &lt;!-- 自定义动画,分别设置效果,将默认v改为name值即可 --&gt; &lt;transition name="my"&gt; &lt;h6 v-if="flag1"&gt;this is h6&lt;/h6&gt; &lt;/transition&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; flag: false, flag1: false &#125;, methods: &#123;&#125; &#125;)&lt;/script&gt; 使用第三方动画库1234567891011&lt;link href="https://cdn.bootcss.com/animate.css/3.7.2/animate.min.css" rel="stylesheet"&gt; &lt;!-- 使用transition元素(vue官方提供),把需要控制的元素包裹起来 如果动画不生效可以加上animated bounceIn 使用:duration设置入场和离场动画时长(ms) =&gt; 分开设置动画时间 :duration="&#123;enter:200,leave:400&#125;" --&gt; &lt;transition enter-active-class="bounceIn" leave-active-class="bounceOut" :duration="400"&gt; &lt;h3 v-if="flag"&gt; this is h3 &lt;/h3&gt;&lt;/transition&gt; 钩子函数实现半场动画1234567891011&lt;transition v-on:before-enter="beforeEnter" v-on:enter="enter" v-on:after-enter="afterEnter" v-on:enter-cancelled="enterCancelled" v-on:before-leave="beforeLeave" v-on:leave="leave" v-on:after-leave="afterLeave" v-on:leave-cancelled="leaveCancelled"&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;style&gt; .ball &#123; background-color: red; width: 20px; padding-top:20px; border-radius: 50%; &#125;&lt;/style&gt;&lt;div id="app"&gt; &lt;input type="button" value="快到碗里来" @click="flag=!flag"&gt; &lt;transition @before-enter="before_enter" @enter="enter" @after-enter="after_enter"&gt; &lt;div class="ball" v-show="flag"&gt;&lt;/div&gt; &lt;/transition&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el:'#app', data: &#123; flag: false &#125;, methods: &#123; //注意: 动画钩子函数的第一个参数el,表示要执行动画的那个dom元素,是个原生的js dom对象 before_enter(el)&#123; //before-enter:表示动画入场之前,此时动画尚未开始,可以在before-enter中,设置元素开始动画之前的起始样式 el.style.transform = 'translate(0,0)' &#125;, enter(el,done)&#123; //一定要设置el.style.transition的时间（如果只使用js钩子的话）,不然没有过渡效果。 el.offsetWidth //enter:表示动画开始之后的样式,设置完成动画后的结束状态 el.style.transform = 'translate(150px,450px)' el.style.transition = 'all 1s ease' //这里的done其实就是after_enter函数的引用 done() &#125;, after_enter(el)&#123; this.flag = !this.flag console.log('ok') &#125; &#125; &#125;)&lt;/script&gt; 列表动画12345678910&lt;!-- 在实现列表过渡的时候,如果需要过渡的元素,是通过v-for循环渲染出来的, 不能使用transition包裹,需要使用trnasitionGroup --&gt;&lt;!-- 给transition-group添加appear属性,实现页面加载入场时候的效果 --&gt;&lt;!-- tag:元素 =&gt; 指定transition-group渲染为指定元素,默认渲染为span --&gt;&lt;transition-group appear enter-active-class="animated rollIn" leave-active-class="animated hinge" :duration="1500" tag="ul"&gt; &lt;li v-for="item in list" :key="item.id"&gt; &#123;&#123;item.name&#125;&#125; &lt;span&gt;&lt;a href="" @click.prevent="remove(item.id)"&gt;删除&lt;/a&gt;&lt;/span&gt; &lt;/li&gt;&lt;/transition-group&gt; Vue组件 什么是组件:组件的出现,就是为了拆分Vue实例的代码量,能够让我们以不同的组件,来划分不同的功能,将来我们需要什么样的功能,就可以去调用对应的组件 组件化和模块化的区别 模块化: 是从代码逻辑的角度进行划分的；方便代码分层开发,保证每个代码模块的职能单一 组件化: 是从UI界面的角度进行划分的；前端的组件化,方便UI组件的重用 全局组件定义的三种方式 使用Vue.extend配合Vue.component方法 1234var login = Vue.extend(&#123; template: '&lt;h1&gt;登录&lt;/h1&gt;'&#125;)Vue.component('login',login) 直接使用Vue.component方法 123Vue.component('register',&#123; template: '&lt;h1&gt;注册&lt;/h1&gt;'&#125;) 将模板字符串,定义到script标签中 123&lt;script id="impl" type="x-template"&gt; &lt;div&gt;&lt;a href="#"&gt;登录&lt;/a&gt; | &lt;a href="注册"&gt;&lt;/a&gt;&lt;/div&gt;&lt;/script&gt; 同时,需要使用Vue.component来定义组件 123Vue.component('account',&#123; template: '#impl'&#125;) show me code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!-- 在被空值的#app外面,使用template元素,定义组件的HTML结构 --&gt;&lt;template id="temp1"&gt; &lt;div&gt; &lt;h1&gt;这是通过template元素,在外部定义的组件结构&lt;/h1&gt; &lt;span&gt;great&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id="register"&gt; &lt;div&gt; &lt;span&gt;register&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;div id="app"&gt; &lt;!-- 如果要使用组件,直接,把组件的名称以HTML标签的形式,引入到页面中;驼峰命名需要转为'-':myComp1 =&gt; my-comp1 --&gt; &lt;my-comp1&gt;&lt;/my-comp1&gt; &lt;my-comp2&gt;&lt;/my-comp2&gt; &lt;my-comp3&gt;&lt;/my-comp3&gt; &lt;login&gt;&lt;/login&gt; &lt;register&gt;&lt;/register&gt;&lt;/div&gt;&lt;script&gt; /** 注意: 不论哪种方式创建出来的组件,组件的template属性指向的模板内容,必须有且只能有唯一的一个根元素 如: &lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt; =&gt; &lt;div&gt;&lt;/div&gt;&lt;span&gt;&lt;/span&gt;会报错,存在两个根元素 **/ //方式1. 使用Vue.extend创建全局Vue组件 var comp1 = Vue.extend(&#123; template: '&lt;h3&gt;这是使用Vue.extend创建的组件&lt;/h3&gt;' &#125;) Vue.component('myComp1', comp1) //方式2. 使用Vue.component('组件的名称',创建出来的组件模板对象) Vue.component('myComp2',&#123; template: '&lt;div&gt;&lt;h3&gt;这是直接使用Vue.component创建出来的组件&lt;/h3&gt;&lt;/div&gt;' &#125;) //方式3 Vue.component('myComp3',&#123; template: '#temp1' &#125;) var vm = new Vue(&#123; el: '#app', components: &#123; //定义私有组件 login: &#123; template: '&lt;h1&gt;Login&lt;/h1&gt;' &#125;, register: &#123; template: '#register' &#125; &#125; &#125;)&lt;/script&gt; 组件定义data和method12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;div id="app"&gt; &lt;comp&gt;&lt;/comp&gt; &lt;counter&gt;&lt;/counter&gt; &lt;counter&gt;&lt;/counter&gt;&lt;/div&gt;&lt;template id="temp1"&gt; &lt;div&gt; &lt;input type="button" value="+1" @click="increment"&gt; &lt;h3&gt;&#123;&#123;count&#125;&#125;&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; //var dataObj = &#123;count: 0&#125; Vue.component('counter',&#123; template: '#temp1', data: function() &#123; //需要在内部返回,如果使用全局组件会共享变量 return &#123;count: 0&#125; &#125;, methods: &#123; increment() &#123; this.count++ &#125; &#125; &#125;) //组件可以有自己的data数据,组件的data和实例的data有点儿不一样,组件的data必须是一个方法,内部还必须返回一个对象 Vue.component('comp',&#123; template: '&lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;', data: function() &#123; return &#123; msg: '这是组件中的data定义的数据' &#125; &#125; &#125;) var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125; &#125;)&lt;/script&gt; 组件切换 方式1： 12345678910111213141516171819202122&lt;div id="app"&gt; &lt;a href="" @click.prevent="flag = true"&gt;登录&lt;/a&gt; &lt;a href="" @click.prevent="flag = false"&gt;注册&lt;/a&gt; &lt;login v-if="flag"&gt;&lt;/login&gt; &lt;register v-else="flag"&gt;&lt;/register&gt;&lt;/div&gt;&lt;script&gt; Vue.component('login',&#123; template: '&lt;h1&gt;login&lt;/h1&gt;' &#125;) Vue.component('register',&#123; template: '&lt;h1&gt;register&lt;/h1&gt;' &#125;) var vm = new Vue(&#123; el: '#app', data: &#123; flag: true &#125; &#125;)&lt;/script&gt; 方式2:实现组件切换 1234567891011121314151617181920212223242526&lt;div id="app"&gt; &lt;a href="" @click.prevent="comName = 'login'"&gt;登录&lt;/a&gt; &lt;a href="" @click.prevent="comName = 'register'"&gt;注册&lt;/a&gt; &lt;!-- Vue提供了component,来展示对应名称的组件;component是一个占位符,:is可以用来栈实的组件名称,直接字符串需要单引号 --&gt; &lt;!-- &lt;component :is="'register'"&gt;&lt;/component&gt; --&gt; &lt;transition mode="out-in" enter-active-class="animated rollIn" leave-active-class="animated hinge" :duration="1500"&gt; &lt;component :is="comName"&gt;&lt;/component&gt; &lt;/transition&gt;&lt;/div&gt;&lt;script&gt; Vue.component('login',&#123; template: '&lt;h1&gt;login&lt;/h1&gt;' &#125;) Vue.component('register',&#123; template: '&lt;h1&gt;register&lt;/h1&gt;' &#125;) var vm = new Vue(&#123; el: '#app', data: &#123; flag: true, comName: 'login' &#125; &#125;)&lt;/script&gt; 组件传值父组件向子组件传值 组件实例定义方式,一定要使用props属性来定义父组件传递过来的数据 1234567891011121314151617181920&lt;div id="app"&gt; &lt;son :finfo="msg"&gt;&lt;/son&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; //data上的数据,都是可读可写的 msg: '这是父组件的消息' &#125;, components: &#123; son: &#123; template: '&lt;h1&gt;子组件&#123;&#123;finfo&#125;&#125;&lt;/h1&gt;', //prop中的数据,都是只读的,无法重新赋值 props: ['finfo'] &#125; &#125; &#125;)&lt;/script&gt; 子组件调用父组件方法,向父组件传值12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;template id="temp1"&gt; &lt;div&gt; &lt;h1&gt;这是子组件&lt;/h1&gt; &lt;input type="button" value="这是子组件的按钮,点击触发父组件传递过来的func方法" @click="myclick"&gt; &lt;/div&gt;&lt;/template&gt;&lt;div id="app"&gt; &lt;!-- 父组件向子组件传递方法,使用的是事件绑定机制;v-on,当我们定义了 一个事件属性之后,子组件就能够通过某些方式来调用这个方法 --&gt; &lt;comp1 @func="show"&gt;&lt;/comp1&gt;&lt;/div&gt;&lt;script&gt; var comp1 = &#123; template: '#temp1', data() &#123; return &#123; sonmsg: &#123;name: 'apple',price: 20&#125; &#125; &#125;, methods: &#123; myclick() &#123; //当点击子组件的按钮,拿到父组件传递过来的func方法 //$emit() : 触发 this.$emit('func',this.sonmsg) &#125; &#125; &#125; var vm = new Vue(&#123; el: '#app', data: &#123; msg: '父组件消息', dataFromSon: null &#125;, methods: &#123; show(data) &#123; this.dataFromSon = data //获取子组件传递过来的数据 console.log(data) &#125; &#125;, components: &#123; comp1 &#125; &#125;)&lt;/script&gt; 案例: 组件实现评论功能1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;div id="app"&gt; &lt;ul class="list-group"&gt; &lt;cmt-box @func="loadComment"&gt;&lt;/cmt-box&gt; &lt;li class="list-group-item" v-for="item in list" :key="item.id"&gt; &lt;span class="badge"&gt;评论人: &#123;&#123;item.user&#125;&#125;&lt;/span&gt; &#123;&#123;item.content&#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;template id="temp1"&gt; &lt;div&gt; &lt;div class="form-group"&gt; &lt;label&gt;评论人:&lt;/label&gt; &lt;input type="text" class="form-control" v-model="user"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;评论内容:&lt;/label&gt; &lt;textarea class="form-control" v-model="content"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;input type="button" value="发表评论" class="btn btn-primary" @click="postComment"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var commentBox = &#123; template: '#temp1', data() &#123; return &#123; user: '', content: '' &#125; &#125;, template: '#temp1', methods: &#123; /** * 发表评论的业务逻辑: * 1.评论数据存到哪里去? 存放到localStorage中 localStorage.setItem('cmts','') * 2.先组织出一个最新的评论数据对象 * 3.想办法将第二步中得到的评论对象,存储到localStorage中 * 3.1 localStorage只支持存放字符串数据,需要先调用JSON.stringify * 3.2 在保存的最新评论之前,先从localStorage中获取到之前的评论数据(string),转换为一个数组对象,然后把 * 最新的评论,push到这个数组 * 3.3 如果获取到localStorage中的评论字符串,为空不存在,则返回一个'[]' 让JSON.parse去转换 * 3.4 把最新的评论列表数组,再次嗲用JSON.stringify转为数组字符串,然后调用localStorage.setItem() **/ postComment() &#123; var comment = &#123;id: Date.now(),user:this.user,content: this.content&#125; var list = JSON.parse(localStorage.getItem('cmts') || '[]') list.push(comment) localStorage.setItem('cmts',JSON.stringify(list)) this.user = this.content = '' this.$emit('func') &#125; &#125; &#125; var vm = new Vue(&#123; el:'#app', data:&#123; list: [ &#123;id: 1,user: 'libai',content: '天生我材必有用'&#125;, &#123;id: 2,user: '江小白',content: '劝君更进一杯酒'&#125; ] &#125;, created() &#123; this.loadComment() &#125;, methods:&#123; loadComment() &#123; var list = JSON.parse(localStorage.getItem('cmts') || '[]') this.list = list &#125; &#125;, components: &#123; 'cmt-box': commentBox &#125; &#125;);&lt;/script&gt; 使用ref获取dom元素和组件引用12345678910111213141516171819202122232425262728293031323334&lt;div id="app"&gt; &lt;input type="button" value="获取元素" @click="getElement"&gt; &lt;h3 ref="mynode"&gt;哈哈&lt;/h3&gt; &lt;login ref="mylogin"&gt;&lt;/login&gt;&lt;/div&gt;&lt;script&gt; var login = &#123; template: '&lt;h1&gt;登录组件&lt;/h1&gt;', data() &#123; return&#123; msg: 'son msg' &#125; &#125;, methods: &#123; show() &#123; console.log('调用了子组件的方法') &#125; &#125; &#125; var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; getElement() &#123; console.log(this.$refs.mylogin.msg) //son msg this.$refs.mylogin.show()//调用了子组件的方法 &#125; &#125;, components: &#123; login &#125; &#125;);&lt;/script&gt; Vue路由什么是路由 后端路由: 对于普通网站,所有的超链接都是URL地址,所有的URL地址都对应服务器上对应的资源 前端路由:对于单页面应用程序来说,主要通过URL中的hash(#号)来实现不同页面之间的切换,同时,hash有一个特点:HTTP请求中不会包含hash相关的内容,所以,单页面程序中的页面跳转主要用hash来实现 在单页面应用程序中,这种通过hash改变来切换页面的方式,称作前端路由 在vue中使用vue-router 导入vue-router组件类库 1&lt;script src="https://cdn.bootcss.com/vue-router/3.1.3/vue-router.min.js"&gt;&lt;/script&gt; 使用router-link组件来导航 123&lt;!-- 使用router-link组件来导航 --&gt;&lt;router-link to="/login"&gt;登录&lt;/router-link&gt;&lt;router-link to="/register"&gt;注册&lt;/router-link&gt; 使用router-view组件来显示匹配到的组件 12&lt;!-- 使用router-view组件来显示匹配到的组件 --&gt;&lt;router-view&gt;&lt;/router-view&gt; 使用Vue.extend创建组件 1234567// 使用Vue.extend来创建登录/注册组件var login = Vue.extend(&#123; template: '&lt;h1&gt;登录组件&lt;/h1&gt;'&#125;)var register = Vue.extend(&#123; template: '&lt;h1&gt;注册组件&lt;/h1&gt;'&#125;) 创建一个路由router实例,通过routers属性来定义路由匹配规则 123456var router = new VueRouter(&#123; routes: [ &#123;path： '/login',component: login&#125;, &#123;path: '/register',component: register&#125; ]&#125;) 使用router属性来使用路由规则 1234var vm = new Vue(&#123; el: '#app', router: router&#125;) 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;div id="app"&gt; &lt;!-- 注意:此处需要加'#'号 --&gt; &lt;!-- &lt;a href="#/login"&gt;登录&lt;/a&gt; &lt;a href="#/register"&gt;注册&lt;/a&gt; --&gt; &lt;router-link to="/login"&gt;登录&lt;/router-link&gt; &lt;router-link to="/register"&gt;注册&lt;/router-link&gt; &lt;!-- 显示匹配到的组件 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;script&gt; var login = &#123; template: '&lt;h1&gt;登录组件&lt;/h1&gt;' &#125; var register = &#123; template: '&lt;h1&gt;注册组件&lt;/h1&gt;' &#125; //2.创建一个路由对象,当导入vue-router包之后,在window全局对象中,就有了一个路由的构造函数,叫做VueRouter var routerObj = new VueRouter(&#123; //表示路由匹配规则 routes: [ //每个路由规则,都是一个对象,&#123;path: '表示监听哪个路由链接地址'; //component: '表示如果路由是前面匹配到的path,则显示对应组件(值必须是组件模板对象,不能是引用名称)'&#125; &#123;path: '/',redirect: '/register'&#125;, &#123;path: '/login',component: login&#125;, &#123;path: '/register',component: register&#125; ], //使用自定义class //linkActiveClass: 'myactive' &#125;) var vm=new Vue(&#123; el:'#app', data:&#123;&#125;, methods:&#123;&#125;, //将路由规则对象注册到vm实例上,用来监听url地址的变化,然后展示对应的组件 //http://127.0.0.1:5500/router_basic.html#/ =&gt; 会使用#哈希路由 router: routerObj &#125;);&lt;/script&gt; 路由传参 方式1 1234567891011121314151617181920212223242526&lt;div id="app"&gt; &lt;!-- 如果在路由中,使用查询字符串,给路由传参 --&gt; &lt;router-link to="/login?id=10&amp;name=zhangsan"&gt;登录&lt;/router-link&gt; &lt;router-link to="/register"&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;script&gt; var login = &#123; template: '&lt;h1&gt;登录 --- &#123;&#123;$route.query.id&#125;&#125; --- &#123;&#123;$route.query.name&#125;&#125;&lt;/h1&gt;' &#125; var register = &#123; template: '&lt;h1&gt;注册&lt;/h1&gt;' &#125; var route = new VueRouter(&#123; routes: [ &#123;path: '/login',component: login&#125;, &#123;path: '/register',component: register&#125; ] &#125;) var vm = new Vue(&#123; el:'#app', router: route &#125;);&lt;/script&gt; 方式2 123456789101112131415161718192021&lt;div id="app"&gt; &lt;!-- 如果在路由中,使用查询字符串,给路由传参 --&gt; &lt;router-link to="/login/12/zhangsan"&gt;登录&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;script&gt; var login = &#123; template: '&lt;h1&gt;登录 --- &#123;&#123;$route.params.id&#125;&#125; --- &#123;&#123;$route.params.name&#125;&#125;&lt;/h1&gt;' &#125; var route = new VueRouter(&#123; routes: [ &#123;path: '/login/:id/:name',component:login&#125; ] &#125;) var vm = new Vue(&#123; el:'#app', router: route &#125;);&lt;/script&gt; 路由嵌套123456789101112131415161718192021222324252627282930313233343536373839404142&lt;div id="app"&gt; &lt;router-link to="/account"&gt;Account&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;template id="temp1"&gt; &lt;div&gt; &lt;h1&gt;这是Account组件&lt;/h1&gt; &lt;router-link to="/account/login"&gt;登录&lt;/router-link&gt; &lt;router-link to="/account/register"&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var account = &#123; template: '#temp1' &#125; var login = &#123; template: '&lt;h1&gt;登录&lt;/h1&gt;' &#125; var register = &#123; template: '&lt;h1&gt;注册&lt;/h1&gt;' &#125; var router = new VueRouter(&#123; routes: [ &#123; path: '/account', component: account, children: [ &#123;path: 'login',component:login&#125;, &#123;path: 'register',component:register&#125; ] &#125; // &#123;path: '/account/login',component: login&#125;, // &#123;path: '/account/register',component: register&#125; ] &#125;) var vm = new Vue(&#123; el:'#app', router:router &#125;);&lt;/script&gt; 命名视图实现经典布局 标签代码结构 1234567&lt;div id="app"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;div class="content"&gt; &lt;router-view name="a"&gt;&lt;/router-view&gt; &lt;router-view name="b"&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/div&gt; js代码结构 12345678&lt;script&gt; var header = Vue.component('header',&#123; template: '&lt;div class="header"&gt;header&lt;/div&gt;' &#125;) var sidebar = Vue.component('sidebar',&#123; template: '&lt;div class="sidebar"&gt;sidebar&lt;/div&gt;' &#125;)&lt;/script&gt; show me code 1234567891011121314151617181920212223242526272829303132&lt;!-- css样式就不写了 --&gt;&lt;div id="app"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;div class="container"&gt; &lt;router-view name="left"&gt;&lt;/router-view&gt; &lt;router-view name="main"&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var header = &#123; template: '&lt;h1 class="header"&gt;header头部区域&lt;/h1&gt;' &#125; var leftbox = &#123; template: '&lt;h1 class="left"&gt;leftbox侧边栏区域&lt;/h1&gt;' &#125; var mainbox = &#123; template: '&lt;h1 class="main"&gt;mainbox主体区域&lt;/h1&gt;' &#125; var router = new VueRouter(&#123; routes: [ &#123;path: '/',components: &#123; default: header, left: leftbox, main: mainbox &#125;&#125; ] &#125;) var vm=new Vue(&#123; el:'#app', router: router &#125;);&lt;/script&gt; Vue监视案例: watch监视名称改变123456789101112131415161718192021222324&lt;div id="app"&gt; &lt;input type="text" v-model="first_name"&gt; + &lt;input type="text" v-model="last_name"&gt; = &lt;input type="text" v-model="fullname"&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; first_name: '', last_name: '', fullname: '' &#125;, //使用这个属性,可以监视data中指定数据的变化,然后触发这个watch中对应的function处理函数 watch: &#123; first_name: function(newVal,oldVal) &#123; this.fullname = `$&#123;newVal&#125;-$&#123;this.last_name&#125;` &#125;, last_name: function() &#123; this.fullname = `$&#123;this.first_name&#125;-$&#123;this.last_name&#125;` &#125; &#125; &#125;)&lt;/script&gt; watch监视路由改变123456789101112131415161718192021222324252627&lt;script&gt; var login = &#123; template: '&lt;h1&gt;登录&lt;/h1&gt;' &#125; var register = &#123; template: '&lt;h1&gt;注册&lt;/h1&gt;' &#125; var router = new VueRouter(&#123; routes: [ &#123;path: '/login',component: login&#125;, &#123;path: '/register',component: register&#125; ] &#125;) var vm = new Vue(&#123; el: '#app', router: router, watch: &#123; '$route.path': function(newVal,oldVal) &#123; if(newVal === '/login') &#123; console.log('欢迎登录') &#125; else if(newVal === '/register') &#123; console.log('欢迎注册') &#125; &#125; &#125; &#125;) &lt;/script&gt; computed计算属性12345678910111213141516171819&lt;script&gt; var vm=new Vue(&#123; el:'#app', data:&#123; firstname: '', lastname: '' &#125;, methods:&#123;&#125;, //在computed中,可以定义一些属性,这些属性叫做计算属性,计算属性的本质就是一个方法,只不过我们 //在使用这些属性的时候,是把它们的名称直接当作属性来使用,并不会把计算属性当作方法去调用 computed: &#123; //只要计算属性这个function内部,所用到的任何data数据发生变化,就会重新计算这个属性的值 //计算属性的求值结果,会被缓存起来,方便下次使用,如果任何属性未发生改变,不会重新计算属性求值 'fullname': function() &#123; return this.firstname + '-' + this.lastname &#125; &#125; &#125;)&lt;/script&gt; vue render渲染123456789101112131415161718&lt;div id="app"&gt; &lt;login&gt;&lt;/login&gt;&lt;/div&gt;&lt;script&gt; var login = &#123; template: '&lt;h1&gt;这是登录组件&lt;/h1&gt;' &#125; var vm = new Vue(&#123; el:'#app', /** render(h) &#123; //该形参是一个方法，能够把指定的组件模板渲染为html结构 //return的结果会直接替换el指定的那个容器(区别于components) return h(login) &#125; **/ render: h =&gt; h(login) &#125;);&lt;/script&gt; NRM 作用: 提供一些常见的NPM镜像地址,能够让我们快速的切换安装包时候的服务器地址 nrm的安装使用 123456-- 全局安装nrm包$ npm i nrm -g-- 查看当前所有可用的镜像源地址以及当前使用的镜像源地址$ nrm ls-- 切换不同的镜像源地址$ nrm use npm 或 nrm use taobao... Webpack webpack的详细上手,参考写的另一篇文章&lt;&lt;webpack使用教程&gt;&gt; 说明 网页中引用的常见静态资源 JS .js .jsx .coffee .ts(TypeScript) CSS .css .less .sass=&gt;.scss images .jpg .png .gif .bmp .svg 字体文件(fonts) .svg .ttf .eot .woff .woff2 模板文件 .ejs .jade .vue[webpack中定义组件的方式] 引入过多静态资源的问题 网页加载速度慢,需要发起很多二次请求 要处理错综复杂的依赖关系 解决上述问题 合并,压缩,精灵图,图片的base64编码 使用requireJS Gulp,Webpack(推荐) webpack可以做什么事情 能处理js文件之间的互相依赖关系 能处理js的兼容问题,把高级的，浏览器不兼容的语法,转为低级的,浏览器能识别的语法 webpack安装 全局安装webpack 1$ npm i webpack -g 在项目根目录安装到项目依赖中 1$ npm i webpack --save-dev webpack使用vue 安装vue 1$ cnpm i vue -S main.js导入vue.js( 1234567891011121314151617181920212223242526272829303132//在webpack中使用vue//注意: 在webpack中,使用import Vue from 'vue'导入的vue构造函数,功能不完整,只提供了runtime-only方式,并没有提供像网页中那样的使用方式//方式1:import Vue from '../node_modules/vue/dist/vue.js'//方式2://第一步import Vue from 'vue'//第二步:在webpack.config.js设置导入路径module.exports = &#123; ... resolve: &#123; alias: &#123; //设置vue被导入时的路径 'vue$': 'vue/dist/vue.js' &#125; &#125;&#125;/** * 包的查找规则： * 1. 找项目根目录中有没有node_modules文件夹 * 2. 在node_modules中根据包名找vue文件夹 * 3. 在vue文件夹中,找一个package.json的包配置文件 * 4. 在package.json文件中,查找一个main属性[main属性指定了这个包被加载时候的入口文件] * "main": "dist/vue.runtime.common.js"不全 */var vm = new Vue(&#123; el: '#app', data: &#123; msg: '123' &#125;&#125;) 实际开发使用vue 安装vue-loader 12//用于.vue文件$ cnpm i vue-loader vue-template-compiler -D src/login.vue文件(webpack中推荐.vue组件模板文件定义组件,由template,script,style组成) 12345&lt;template&gt; &lt;div&gt; &lt;h1&gt;这是登录组件&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt; main.js入口文件 123456789101112131415161718import Vue from 'vue'//导入login组件import login from './login.vue'/** * 包的查找规则： * 1. 找项目根目录中有没有node_modules文件夹 * 2. 在node_modules中根据包名找vue文件夹 * 3. 在vue文件夹中,找一个package.json的包配置文件 * 4. 在package.json文件中,查找一个main属性[main属性指定了这个包被加载时候的入口文件] */var vm = new Vue(&#123; el: '#app', render(createElements) &#123; return createElements(login) &#125;&#125;) webpack.config.js 12345678910111213141516171819202122232425262728293031323334353637383940414243const path = require('path')//导入在内存中生成html页面的插件,只要是插件都要放到plugins节点中去const htmlWebpackPlugin = require('html-webpack-plugin')//导入vueloaderpluginconst VueLoaderPlugin = require('vue-loader/lib/plugin')module.exports = &#123; entry: './src/main.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;, plugins: [ //创建一个在内存中生成html页面的插件 new htmlWebpackPlugin(&#123; //指定模板页面,将来会根据指定的模板路径生成内存中的页面 template: path.join(__dirname,'./src/index.html'), //指定生成的页面名称 filename: 'index.html' &#125;), new VueLoaderPlugin() ], module: &#123; //这个节点用于配置所有第三方模块加载器 rules: [ //所有第三方模块的匹配规则 &#123;test: /\.css$/,use: ['style-loader','css-loader']&#125;, //配置处理.less文件的第三方loader &#123;test: /\.less$/,use: ['style-loader','css-loader','less-loader']&#125;, &#123;test: /\.scss$/,use: ['style-loader','css-loader','sass-loader']&#125;, &#123;test: /\.(jpg|png|gif|jpeg|bmp)$/,use: ['url-loader?limit=10&amp;name=[hash:8][name].[ext]']&#125;, &#123;test: /\.(ttf|eot|svg|woff|woff2)$/,use: ['url-loader']&#125;, //配置babel来转换高级的es语法 &#123;test: /\.js$/,use: 'babel-loader',exclude: /node_modules/&#125;, //配置文件转换vue &#123;test: /\.vue$/,use: 'vue-loader'&#125; ] &#125;, resolve: &#123; alias: &#123; //设置vue被导入时的路径 'vue$': 'vue/dist/vue.js' &#125; &#125;&#125;; index.html 123&lt;div id="app"&gt; &lt;login&gt;&lt;/login&gt;&lt;/div&gt; export default和export //node中向外暴露成员的形式 module.exports = {}和exports = {} //在es6中导入模块: import 模块名称 from ‘模块标识符’ / import ‘表示路径’ //es6向外暴露成员: export default/export export:使用export向外暴露的成员,只能使用{}的形式接收,可以向外暴露多个成员 export.default:在一个模块中,只允许向外暴露一次 test.js 12345678910111213141516// module.exports = &#123;// name: 'zhangsan',// age: 20// &#125;var info = &#123; name: 'zhangsan', age: 20&#125;export default info//可以不全部导出 import info,&#123;title&#125; =&gt; 只导出titleexport var title = 'hello'export var content = 'world'ecport var color = 'red' main.js 123456//export default暴露的,可以任意变量接收import person,&#123;title,content,color as co&#125; from './test.js'console.log(person) //&#123;name:'zhangsan',age:20&#125;console.log(title) //helloconsole.log(content)//worldconsole.log(co) //red 结合webpack使用vue-router 使用参考: vue-router npm 安装 安装vue-router 1npm install vue-router 如果在一个模块化工程中使用它，必须要通过 Vue.use() 明确地安装路由功能： 1234567891011121314151617import Vue from 'vue'import VueRouter from 'vue-router'import account from './vue/account.vue'const router = new VueRouter(&#123; routes: [ &#123;path:'/login',component: account&#125; //http://localhost:3000/#/login ]&#125;)Vue.use(VueRouter)var vm = new Vue(&#123; el: '#app', render: h =&gt; h(app), //如果存在render,必须把router组件放入app.vue中 router&#125;) account.vue 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;h1&gt;这是登录组件&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt; /* scoped:定义为私有样式(默认全局样式) 普通的style标签只支持普通的样式,如果要启用scss或less,需要为style元素,设置lang属性 */ body &#123; div &#123; color: red; &#125; &#125;&lt;/style&gt; app.vue 123456&lt;template&gt; &lt;div&gt; &lt;h1&gt;这是app组件&lt;/h1&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 抽离路由模块 新建router.js用于抽离router模块 12345678910import VueRouter from 'vue-router'import account from './vue/account.vue'const router = new VueRouter(&#123; routes: [ &#123;path:'/login',component: account&#125; ]&#125;)export default router main.js 123456789101112import Vue from 'vue'import app from './vue/app.vue'import VueRouter from 'vue-router'Vue.use(VueRouter)import router from './router.js'var vm = new Vue(&#123; el: '#app', render: h =&gt; h(app), router&#125;) 其他的不改变 Mint UI 基于 Vue.js 的移动端组件库,只适用于vue项目(具体操作请参考官网,此处就只简单上手) 安装 12345// 安装# Vue 1.xnpm install mint-ui@1 -S# Vue 2.0npm install mint-ui -S 引入组件 12345678// 引入全部组件,部分引入配置见mint ui官网import Vue from 'vue';import Mint from 'mint-ui';Vue.use(Mint);// 按需引入部分组件,组件参考mint ui官网import &#123; Cell, Checklist &#125; from 'mint-ui';Vue.component(Cell.name, Cell);Vue.component(Checklist.name, Checklist); app.vue 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;mt-button type=&quot;default&quot; @click=&quot;show&quot;&gt;danger&lt;/mt-button&gt; &lt;h1&gt;这是app组件&lt;/h1&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;//导入toastimport &#123;Toast&#125; from &apos;mint-ui&apos;export default &#123; data() &#123; return &#123;&#125; &#125;, methods: &#123; show() &#123; Toast(&apos;hello&apos;) &#125; &#125;&#125;&lt;/script&gt; MUI 使用方法:github&gt;mui项目拷贝,复制dist目录到src&gt;lib下 在main.js引用 12//dist改名为mui,方便区分import './lib/mui/css/mui.min.css' 在app.vue中引用 12&lt;!-- 示例 --&gt;&lt;button type=&quot;button&quot; class=&quot;mui-btn mui-btn-royal mui-btn-outlined&quot;&gt;紫色&lt;/button&gt; vuex vuex是vue配套的公共数据管理工具,可以把一些共享的数据,保存到vuex中,方便整个程序中的任何组件直接获取或修改我们的公共数据 npm安装 1$ npm install vuex --save main.js 1234import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex) 创建vuex实例,得到数据仓储对象,并挂载到vm实例上 12345678910111213141516171819202122232425262728293031323334var store = new Vuex.Store(&#123; state: &#123; //专门用于存储数据 count: 0 &#125;, mutations: &#123; //如果要操作store中的state值,只能通过调用mutation提供的方法,才能操作对应的数据, //不推荐直接操作state中的数据,避免数据紊乱,不能快速定位到错误原因 increment(state,num) &#123; state.count++ &#125; &#125;, getters: &#123; //注意:getters,只负责对外提供数据,不负责修改数据,如果需要修改使用mutations //$store.getters.mutations mutations: function(state) &#123; //如果引用的state内部数据发生改变,就会触发 return state.count &#125; &#125; //如果子组件想要调用mutations中的方法,只能使用this.$store.commit('方法名')&#125;)//1. state中的数据,不能直接修改,如果想修改,必须通过mutations//2. 如果组件想要直接从state中获取数据,需要this.$store.state.***//3. 如果组件,想要修改数据,必须使用mutations提供的方法,需要通过this.$store.commit('方法名称','可选参数')//4. 如果store中state上的数据,在对外提供的时候,需要做一层包装,推荐使用getters,如果需要使用getters,使用this.$store.getters.***var vm = new Vue(&#123; el: '#app', render: h =&gt; h(app), router, store //将vuex创建的store挂载到vm实例上&#125;) 获取vuex上的数据(不推荐) 123456789101112131415&lt;h1&gt; &lt;!-- 不推荐直接获取 --&gt; &#123;&#123;$store.state.count&#125;&#125;&lt;/h1&gt;&lt;script&gt; export default() &#123; methods: &#123; countChanged() &#123; //调用vuex中increment方法 this.$store.commit('increment',1) &#125; &#125; &#125;&lt;/script&gt; 资料参考 vue.js guide vue-router guide vuex guide keycode键盘 按键 - 键码 对应表 animate.css webpack windows npm安装webpack webpack和webpack cli的安装卸载 mint ui]]></content>
      <categories>
        <category>技术</category>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[webpack快速上手]]></title>
    <url>%2Fposts%2Ff2244df3%2F</url>
    <content type="text"><![CDATA[基于webpack4.+(webpack4以下不适用)=&gt;推荐根据官方文档进行使用 – 按照本教程,需要将webpack删除干净,否则可能与旧版本冲突 目录结构 12345678910111213141516|-dist |-...|-node_modules |-...|-src |-css |-... |-js |-... |-images |-... |-index.html |-main.js =&gt; 项目的js入口文件|-package.lock.json|-package.json|-webpack.config.js 必须步骤 初始化项目 1$ npm init -y (全部默认yes) 安装webpack 12$ npm install --save-dev webpack$ npm install --save-dev webpack@&lt;version&gt; 安装webpack-cli(4.+必须安装) 1$ npm install --save-dev webpack-cli webpack.config.js 12345678910const path = require('path');module.exports = &#123; entry: './src/main.js', //入口文件 output: &#123; //打包到dist/bundle.js filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125;; package.json=&gt;指向webpack.config.js 12345"scripts": &#123; "start": "webpack --config webpack.config.js", "dev": "webpack --mode development", "build": "webpack --mode production"&#125; 运行 1$ npm run start|dev|build =&gt;"start|dev|build"来源于package.json中的配置 在index.html中引入bundle.js即可在浏览器运行 1&lt;script src="../dist/bundle.js"&gt;&lt;/script&gt; 常见包安装jquery 安装1$ npm i jquery -S bootstrap安装1$ npm i bootstrap@3 webpack-dev-server 这个工具用来实现自动打包编译 下载webpack-dev-server 1$ npm i webpack-dev-server -D 配置方式1 配置package.json script 1234"server": "webpack-dev-server",//复杂配置(自动打开,端口3000,根路径src,热部署)"server": "webpack-dev-server --open --port 3000 --contentBase src --hot" 配置方式2 12345678910111213141516"server": "webpack-dev-server",// 适用于webpack4+module.exports = &#123; entry: './src/main.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;, devServer: &#123; open: true, //自动打开浏览器 port: 3000, //端口 contentBase: 'src',//设置托管根目录 hot: true //启用热更新 &#125;&#125;; 运行 1npm run name(package.json配置的name:'server') 12345//保存后会自动打包,需要更换为&lt;script src="/bundle.js"&gt;&lt;/script&gt; =&gt; localhost:8080/bundle.jsi ｢wds｣: Project is running at http://localhost:8080/i ｢wds｣: webpack output is served from /i ｢wds｣: Content not from webpack is served from L:\front_project\webpack_studyi ｢wdm｣: Hash: 3bf740352707131c0daa html-webpack-plugin安装 自动在内存中根据指定页面生成一个内存的页面 自动把打包好的bundle.js追加到页面中去 1$ npm i html-webpack-plugin -D js处理代码见下方webpack.config.js(webpack只能默认打包处理js类型文件,其他需要相应插件) 打包处理css文件(需要其他插件) 安装style-loader css-loader 1$ cnpm i style-loader css-loader -D 配置文件webpack.config.js | main.js 1234567891011121314151617181920212223242526272829const path = require('path')//导入在内存中生成html页面的插件,只要是插件都要放到plugins节点中去const htmlWebpackPlugin = require('html-webpack-plugin')module.exports = &#123; entry: './src/main.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;, plugins: [ //创建一个在内存中生成html页面的插件 new htmlWebpackPlugin(&#123; //指定模板页面,将来会根据指定的模板路径生成内存中的页面 template: path.join(__dirname,'./src/index.html'), //指定生成的页面名称 filename: 'index.html' &#125;) ], module: &#123; //这个节点用于配置所有第三方模块加载器 rules: [ //所有第三方模块的匹配规则 //配置所有.css文件的第三方loader规则 =&gt; 奇葩:调用规则是从右到左,注意顺序别写反了 &#123;test: /\.css$/,use: ['style-loader','css-loader']&#125; ] &#125;&#125;;//main.js导入import './css/style.css' 打包处理less文件 安装less 12//安装less与less loader$ npm install --save-dev less-loader less 配置文件webpack.config.js | main.js 1234567rules: [ //所有第三方模块的匹配规则(less安装试了几遍,开始一直报错,但是莫名其妙又好了) &#123;test: /\.css$/,use: ['style-loader','css-loader']&#125;, &#123;test: /\.css$/,use: ['style-loader','css-loader','less-loader']&#125;]//main.js导入import './css/style.less' 打包处理sass文件(不能使用npm,有墙) 安装sass(sass-loader依赖于node-sass) 12cnpm install node-sass -Dcnpm install sass-loader -D 配置文件webpack.config.js | main.js 123456rules: [ &#123;test: /\.scss$/,use: ['style-loader','css-loader','sass-loader']&#125;]//main.js导入import './css/style.scss' 打包处理图片 安装url-loader(依赖于file-loader) 1$ cnpm i url-loader file-loader -D 配置文件webpack.config.js 1234rules: [ //limit给定的值如果大于图片字节,采用base64编码(8为hash+name不变,后缀不变) &#123;test: /\.(jpg|png|gif|jpeg|bmp)$/,use: ['url-loader?limit=7631&amp;name=[hash:8]-[name].[ext]']&#125;] 打包处理字体文件 main.js 12//引用node_modules中文件,可以省略node_modules/,不写默认在node_modules中查找import 'bootstrap/dist/css/bootstrap.css' webpack.config.js 1234//还是使用url-loaderrules: [ &#123;test: /\.(ttf|eot|svg|woff|woff2)$/,use: ['url-loader']&#125;] babel 在webpack中,默认只能处理一部分es6的语法,一些更高级的es6甚至es7语法,webpack是处理不了的,需要借助第三方的loader,来将高级语法转为低级语法,将结果交给webpack打包到bundle.js 安装两套包 123$ cnpm i babel-loader @babel/core -D//语法插件(用于转换es)$ cnpm i @babel/preset-env @babel/polyfill -D webpack.config.js 1234rules: [ //如果不排除node_modules,则会将node_moodules中所有的第三方js文件打包编译 &#123;test: /\.js$/,use: 'babel-loader',exclude: /node_modules/&#125;] 在项目的根目录中,新建一个.babelrc的配置文件,这个配置文件属于json格式(不能写注释,字符串必须双引号) .babelrc =&gt; 有兴趣的可以去了解下babel预设 12345678910111213&#123; "presets": [ [ "@babel/preset-env", &#123; "useBuiltIns": "usage", "targets": &#123; "browsers": ["last 2 versions", "ie &gt;= 10"] &#125; &#125; ] ]&#125; 安装babel.config.js需要插件 1$ cnpm i @babel/plugin-proposal-class-properties babel.config.js 1234module.exports = &#123; //使用箭头函数还需要加入箭头函数插件(下面) plugins: [ "@babel/plugin-proposal-class-properties" ]&#125; bug解决方案: 删除node_modules,然后npm install =&gt;解决大部分问题]]></content>
      <categories>
        <category>技术</category>
        <category>webpack</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[速查表]]></title>
    <url>%2Fposts%2F1b392612%2F</url>
    <content type="text"><![CDATA[前端开发速查表 速查表集合:https://www.html.cn/dev/ 此处只对常用速查表进行展示 Javascript ES2015+ 新特性 Javascript Javascript 正则表达式 Flexbox Vuejs Vuex Angular 4 React Redux:downloaf pdf SASS Stylus GraphQL jQuery CSS3 HTML5 后端速查表Java 8 数据库mysql]]></content>
      <categories>
        <category>工具</category>
        <category>速查表</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot与安全]]></title>
    <url>%2Fposts%2F12cfed1f%2F</url>
    <content type="text"><![CDATA[Spring Boot与安全 这个是直接对教学视频做的整理,避免用到的时候又得到处搜索,视频来源(b站:https://www.bilibili.com/video/av38657363/?p=99) 测试项目请直接在此处下载基础代码进行测试:https://www.lanzous.com/i6ei0ve Spring Security引入maven123456789101112131415&lt;!-- thymeleaf --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- web --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- security --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 编写Spring Security配置类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; /** * 控制请求权限 * &lt;em&gt; * The most basic configuration defaults to automatically generating a login page at * the URL "/login", redirecting to "/login?error" for authentication failure. * &lt;/em&gt; * &lt;desc&gt; * VIP1: 只能访问/level1/** * VIP2: 只能访问/level2/** * VIP3: 只能访问/level3/** * &lt;/desc&gt; * @param http * @throws Exception */ @Override protected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() //定制请求的授权规则 .antMatchers("/").permitAll() .antMatchers("/level1/**").hasRole("VIP1") .antMatchers("/level2/**").hasRole("VIP2") .antMatchers("/level3/**").hasRole("VIP3"); //开启自动配置的登录功能,如果没有权限就进入登录页面(自带登录页面) http.formLogin(); //开启自动配置的注销功能 http.logout(); &#125; /** * 定义认证规则 * @param auth * @throws Exception */ @Override public void configure(AuthenticationManagerBuilder auth) throws Exception &#123; //定义用户(此处只是测试,实际还是应该保存在数据库) auth.inMemoryAuthentication() .passwordEncoder(new BCryptPasswordEncoder()) .withUser("zhangsan").password(new BCryptPasswordEncoder().encode("123")).roles("VIP1,VIP2") .and().withUser("lisi").password(new BCryptPasswordEncoder().encode("123")).roles("VIP2") .and().withUser("wangwu").password(new BCryptPasswordEncoder().encode("123")).roles("VIP3"); &#125;&#125; 登录功能 登出功能12&lt;!-- http.logout():The default is that accessing the URL * "/logout" will log the user out by invalidating the HTTP Session --&gt;&lt;form th:action="@&#123;/logout&#125;" th:method="post"&gt; &lt;input type="submit" value="注销"&gt;&lt;/form&gt; 错误处理 解决方法:(passwordEncoder(new BCryptPasswordEncoder())) 需求说明: 当用户没有访问权限,信息对用户隐藏 解决方案引入thymeleaf spring security支持1234&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt;&lt;/dependency&gt; 引入thymeleaf spring security名称空间welocome.html: 123&lt;html lang="es" xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org" xmlns:sec="http://www.thymeleaf.org/extras/spring-security"&gt; 错误处理 开始根据视频一直出问题,后来在github issue里面找到了解决方法: address:https://github.com/thymeleaf/thymeleaf-extras-springsecurity/issues/61 123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- 未经过身份验证 --&gt;&lt;div sec:authorize="!isAuthenticated()"&gt; &lt;h2 align="center"&gt;游客您好，如果想查看武林秘籍 &lt;a th:href="@&#123;/login&#125;"&gt;请登录&lt;/a&gt;&lt;/h2&gt;&lt;/div&gt;&lt;!-- 经过身份验证 --&gt;&lt;div sec:authorize="isAuthenticated()"&gt; &lt;h2&gt;&lt;span sec:authentication="name"&gt;&lt;/span&gt;,您好,您的角色有: &lt;span sec:authentication="principal.authorities"&gt;&lt;/span&gt;&lt;/h2&gt; &lt;form th:action="@&#123;/logout&#125;" th:method="post"&gt; &lt;input type="submit" value="注销"&gt; &lt;/form&gt;&lt;/div&gt;&lt;div sec:authorize="hasRole('VIP1')"&gt; &lt;h3&gt;普通武功秘籍&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;a th:href="@&#123;/level1/1&#125;"&gt;罗汉拳&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href="@&#123;/level1/2&#125;"&gt;武当长拳&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href="@&#123;/level1/3&#125;"&gt;全真剑法&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;div sec:authorize="hasRole('VIP2')"&gt; &lt;h3&gt;高级武功秘籍&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;a th:href="@&#123;/level2/1&#125;"&gt;太极拳&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href="@&#123;/level2/2&#125;"&gt;七伤拳&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href="@&#123;/level2/3&#125;"&gt;梯云纵&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;div sec:authorize="hasRole('VIP3')"&gt; &lt;h3&gt;绝世武功秘籍&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;a th:href="@&#123;/level3/1&#125;"&gt;葵花宝典&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href="@&#123;/level3/2&#125;"&gt;龟派气功&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href="@&#123;/level3/3&#125;"&gt;独孤九剑&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 张三只有VIP1,VIP2权限,所以VIP3对其隐藏 开启remember me功能WebSecurityConfig.java 12//开启记住我功能http.rememberMe(); 有图片可以看出,开启后会出现remember me选项(实现原理:登录成功以后,携带此cookie,只要验证通过就会免登录) 自定义登录页面1http.formLogin().usernameParameter("user").passwordParameter("pwd").loginPage("/userlogin"); 1234&lt;!-- 修改href为自定义login page requestmapping--&gt;&lt;div sec:authorize="!isAuthenticated()"&gt; &lt;h2 align="center"&gt;游客您好，如果想查看武林秘籍 &lt;a th:href="@&#123;/userlogin&#125;"&gt;请登录&lt;/a&gt;&lt;/h2&gt;&lt;/div&gt; 1234567&lt;div align="center"&gt; &lt;form th:action="@&#123;/userlogin&#125;" method="post"&gt; 用户名:&lt;input name="user"/&gt;&lt;br&gt; 密码:&lt;input name="pwd"&gt;&lt;br/&gt; &lt;input type="submit" value="登陆"&gt; &lt;/form&gt;&lt;/div&gt; 自定义remember me1http.rememberMe().rememberMeParameter("remember"); 123456789&lt;div align="center"&gt; &lt;form th:action="@&#123;/userlogin&#125;" method="post"&gt; 用户名:&lt;input name="user"/&gt;&lt;br&gt; 密码:&lt;input name="pwd"&gt;&lt;br/&gt; &lt;!-- 自定义remember me --&gt; &lt;input type="checkbox" name="remember"&gt; &lt;input type="submit" value="登陆"&gt; &lt;/form&gt;&lt;/div&gt; 资料参考: securing a web application]]></content>
      <categories>
        <category>技术</category>
        <category>Spring-Boot</category>
      </categories>
      <tags>
        <tag>security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot与任务]]></title>
    <url>%2Fposts%2F9edd11df%2F</url>
    <content type="text"><![CDATA[异步任务demo在启动类上添加@EnableAsync:开启异步注解controller 123456789101112@RestControllerpublic class AsyncController &#123; @Autowired AsyncService asyncService; @GetMapping("/hello") public String hello() &#123; asyncService.hello(); return "success"; &#125;&#125; service 12345678910111213@Servicepublic class AsyncService &#123; @Async //告诉spring这是一个异步方法 public void hello() &#123; try &#123; Thread.sleep(1000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println("处理数据中..."); &#125;&#125; 定时任务 字段 允许值 允许的特殊字符 秒 0-59 ,-/* 分 0-59 ,-/* 小时 0-23 ,-/* 日期 1-31 ,-*?/LWC 月份 1-12 ,-/* 星期 0-7或SUN-SAT,0,7是SUN ,-*?/LC# 特殊字符 代表含义 , 枚举 - 区间 / 步长 * 任意 ? 日/星期冲突匹配 L 最后 W 工作日 C 和Calendar联系后计算过的值 # 星期 4#2:第2个星期四 demo在启动类上添加@EnableScheduling//开启基于注解的定时任务 1234567891011121314/** * on the second as well as minute, hour, day of month, month and day of week. * such as &#123;@code "0 * * * * MON-FRI"&#125;:周一到周五每分钟0秒启动 * [* * * * * MON-FRI] 周一到周五每秒执行一次 * [0 0/5 14,18 * * ?] 每天14点整和18点整,每隔5分钟执行一次 * [0 15 10 ? * 1-6] 每个月的周一至周六10:15分执行一次 * [0 0 2 ? * 6L] 每个月的最后一个周六凌晨2点执行一次 * [0 0 2 LW * ?] 每个月最后一个工作日凌晨2点执行一次 * [0 0 2-4 ? * 1#1] 每个月的第一个周一凌晨2点到4点期间,每个整点执行一次 */@Scheduled(cron = "0/4 * * * * MON-FRI")public void hello() &#123; System.out.println("hello");&#125; 邮件任务starter引入1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt; 123456789101112131415161718192021222324252627@ConfigurationProperties(prefix = "spring.mail")public class MailProperties &#123; private static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8; /** * SMTP server host. For instance, `smtp.example.com`. */ private String host; /** * SMTP server port. */ private Integer port; /** * Login user of the SMTP server. */ private String username; /** * Login password of the SMTP server. */ private String password; ...&#125; 注意:想要使用qq邮箱需要开启POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务,并获取授权码 application.yml 1234567891011spring: mail: username: 1690150504@qq.com ## 敏感信息就不显示了,此处不是qq密码,而是授权码 password: **** host: smtp.qq.com properties: mail: smtp: ssl: enable: true 简单邮件发送123456789101112131415161718192021@AutowiredJavaMailSenderImpl javaMailSenderImpl;/** * 简单邮件发送 */@Testpublic void contextLoads() &#123; SimpleMailMessage message = new SimpleMailMessage(); //邮件设置 //邮件标题 message.setSubject("通知,今晚开会"); //邮件内容 message.setText("今晚7:30开会"); //收件人 message.setTo("529691071@qq.com"); //发件人 message.setFrom("1690150504@qq.com"); javaMailSenderImpl.send(message);&#125; 邮件发送成功: 复杂邮件发送1234567891011121314151617181920/** * 带附件邮件发送 */@Testpublic void sendWithFile() throws MessagingException &#123; //创建一个复杂的消息邮件 MimeMessage message = javaMailSenderImpl.createMimeMessage(); //MimeMessage mimeMessage, boolean multipart MimeMessageHelper helper = new MimeMessageHelper(message, true); //邮件设置 helper.setSubject("通知,今晚开会"); //默认不开启html helper.setText("&lt;b style='color:red'&gt;今晚7:30开会&lt;/b&gt;",true); helper.setTo("2712313163@qq.com"); helper.setFrom("1690150504@qq.com"); helper.addAttachment("1.jpg",new File("C:\\Users\\a1690\\AppData\\Roaming\\Typora\\typora-user-images\\1569326673463.png")); helper.addAttachment("2.jpg",new File("C:\\Users\\a1690\\AppData\\Roaming\\Typora\\typora-user-images\\1569330211331.png")); javaMailSenderImpl.send(message);&#125; 不过测试发现,这类邮件直接被加入了qq垃圾箱,囧 资料参考:cron表达式示例 qq邮件客户端配置 qq邮箱授权码获取]]></content>
      <categories>
        <category>技术</category>
        <category>Spring-Boot</category>
      </categories>
      <tags>
        <tag>task</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用linux命令]]></title>
    <url>%2Fposts%2F4206c037%2F</url>
    <content type="text"><![CDATA[此处列举平时经常用到的命令,免得每次使用都要查询(此处默认拥有sudo权限) 网络相关 修复网络只有127..0.0.1问题 1dhclient -v 连接vps服务器 1ssh root@服务器ip 查看本机ip 1ifconfig 权限相关 赋予管理员权限1sudo su 文件操作 递归删除根目录下所有文件(有兴趣的小伙伴可以试下) 1rm -rf /* 文件删除 1rm file_name 移动文件 1mv source dest 查看当前文件所在目录 1pwd 列举当前文件夹下文件 1ls 获取文件读写权限 1chmod 777 * 创建文件 121. echo &gt;&gt; demo.txt2. touch demo.txt 编辑文件 123456-- vi编辑文件vi file_name-- vim编辑文件vim file_name-- 编辑器编辑文件gedit file_name 创建文件夹 1mkdir directory 删除文件夹 1rmdir directory 终端操作相关 查看命令历史 1history 清空终端 1clear v2ray脚本1bash &lt;(curl -s -L https://233blog.com/v2ray.sh) 包管理 更新apt软件包 1apt-get update 安装软件包 1apt-get install package_name 搜索软件包 1apt search name]]></content>
      <categories>
        <category>技术</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>terminal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[elasticsearch上手]]></title>
    <url>%2Fposts%2Fd9b5c3c%2F</url>
    <content type="text"><![CDATA[ElasticSearch遵循restful风格;该文章只是elasticsearch入门不做详细阐述,详细信息请查看官方文档 docker安装ElasticeSearch1234567## pull ElasticSearchdocker pull elasticsearch## create networkdocker network create somenetwork## docker rundocker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" elasticsearch:tag ElasticSearch测试 示例参考权威指南中文版:索引员工文档(此处使用postman来进行测试)。DELEATE,HEAD请求有兴趣的朋友可以试下,这儿就不一一试了 PUT请求 GET请求数据存入后,我们再通过get请求来试着进行下查询 数据存在 数据不存在 查询所有员工信息1GET /megacorp/employee/_search 搜索姓名为smith的员工12345678910## 使用轻量搜索进行查询GET /megacorp/employee/_search?q=last_name:Smith## 查询表达式进行查询&#123; "query" : &#123; "match" : &#123; "last_name" : "Smith" &#125; &#125;&#125; Spring Boot整合ElasticSearchSpringBoot支持两种技术来实现与ES交互(1:Jest 2.SpringData ElasticSearch) Jest简单上手从JestAutoConfiguration可以得知,如果使用Jest需要导入对应的包,版本需要和version保持一致 12345&lt;dependency&gt; &lt;groupId&gt;io.searchbox&lt;/groupId&gt; &lt;artifactId&gt;jest&lt;/artifactId&gt; &lt;version&gt;6.3.1&lt;/version&gt; &lt;/dependency&gt; 123456789101112131415161718192021@ConfigurationProperties(prefix = "spring.elasticsearch.jest")public class JestProperties &#123; /** * Comma-separated list of the Elasticsearch instances to use. * 默认:http://localhost:9200 */ private List&lt;String&gt; uris = new ArrayList&lt;&gt;(Collections.singletonList("http://localhost:9200")); /** * Login username. */ private String username; /** * Login password. */ private String password; ...&#125; 配置yml 1234spring: elasticsearch: jest: uris: http://192.168.91.131:9200 创建article bean 12345678public class Article &#123; @JestId private Integer id; private String author; private String title; private String content; ...&#125; 测试类 12345678910111213141516@AutowiredJestClient jestClient;@Testpublic void contextLoads() throws IOException &#123; //1.给Es索引(保存)一个文档 Article article = new Article(); article.setId(1); article.setAuthor("john"); article.setTitle("震惊!..."); article.setContent("page"); //索引.类型.编号(类似:/megacorp/employee/1示例,此处已经在bean里面指定了id) Index index = new Index.Builder(article).index("lsj").type("article").build(); jestClient.execute(index);&#125; 发送请求进行测试 测试搜索 1234567891011121314151617/** * 测试搜索 */@Testpublic void search() throws IOException &#123; String json = "&#123;\n" + " \"query\" : &#123;\n" + " \"match\" : &#123;\n" + " \"author\" : \"john\"\n" + " &#125;\n" + " &#125;\n" + "&#125;"; Search search = new Search.Builder(json).addIndex("lsj").addType("article").build(); SearchResult result = jestClient.execute(search); //&#123;"took":511,"timed_out":false,"_shards":&#123;"total":5,"successful":5,"skipped":0,"failed":0&#125;,"hits":&#123;"total":1,"max_score":0.2876821,"hits":[&#123;"_index":"lsj","_type":"article","_id":"1","_score":0.2876821,"_source":&#123;"id":1,"author":"john","title":"震惊!...","content":"page"&#125;&#125;]&#125;&#125; System.out.println(result.getJsonString());&#125; 简单上手SpringData ElasticSearch- 引入starter 引入starter 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt; &lt;/dependency&gt; 配置yml 12345spring: data: elasticsearch: cluster-name: docker-cluster cluster-nodes: 192.168.91.131:9300 cluster-name需要一致 使用ElasticsearchRepository测试1234567@Document(indexName = "lsj",type = "book")public class Book &#123; private Integer id; private String bookName; private String author; ...&#125; 123456789public interface BookRepository extends ElasticsearchRepository&lt;Book,Integer&gt; &#123; /** * search by bookName * @param bookName * @return */ List&lt;Book&gt; findByBookNameLike(String bookName);&#125; 123456789101112@Testpublic void repository() &#123; // 新增测试 Book book = new Book(); book.setAuthor("lsj"); book.setBookName("harry"); book.setId(1); bookRepository.index(book); //查询测试 List&lt;Book&gt; result = bookRepository.findByBookNameLike("harry");&#125; 资料参考:docker:elasticsearch elasticsearch权威指南中文版 springboot elasticsearch docs]]></content>
      <categories>
        <category>技术</category>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery插件$.fn]]></title>
    <url>%2Fposts%2Fdc1ef41d%2F</url>
    <content type="text"><![CDATA[因为这段时间一直在做后端的开发,再加上以前对$.fn有点儿不清楚,所以专门写篇博客加深理解,错误的地方希望指正。($.fn即jQuery.fn) $.fn源码jQuery.fn源码:从源码可以看出$.fn实际就是jQuery的原型,生成一个Object实例对象 123456789101112jQuery.fn = jQuery.prototype = &#123; // The current version of jQuery being used jquery: version, constructor: jQuery, // The default length of a jQuery object is 0 length: 0 ...&#125; 我们可以试着打印$.fn会发现它是一个Object对象,内部包含jquery的方法及属性 $.fn进行扩展示例:通过$.fn修改颜色 123456789&lt;h1 id="word"&gt;HELLO WORLD&lt;/h1&gt;&lt;script&gt; $.fn.red = function()&#123; this.css(&#123;"color":"red"&#125;); &#125; $(function() &#123; $("#word").red(); &#125;)&lt;/script&gt; $.fn.extend此处就直接引官网的api说明 Description: Merge the contents of an object onto the jQuery prototype to provide new jQuery instance methods.(大意是将对象的内容合并到jQuery原型上，以提供新的jQuery实例方法) 示例:通过jQuery.fn.extend对复选框进行选中以及取消选中 12345678910111213141516171819&lt;span&gt;&lt;input type="checkbox" name="huawei"&gt;华为&lt;/span&gt;&lt;span&gt;&lt;input type="checkbox" name="xiaomi"&gt;小米&lt;/span&gt;&lt;script&gt;jQuery.fn.extend (&#123; check: function() &#123; return this.each(function() &#123; this.checked = true; &#125;); &#125;, uncheck: function() &#123; return this.each(function() &#123; this.checked = false; &#125;) &#125;&#125;)$(function() &#123; $("input[type='checkbox']").check();&#125;)&lt;/script&gt; 示例2:通过jQuery.fn.extend实现点击编辑框弹出编辑框内容 1234567891011&lt;textarea id="edit"&gt;&lt;/textarea&gt;&lt;script&gt; jQuery.fn.extend (&#123; alertWhileClick: function() &#123; $(this).click(function() &#123; alert($(this).val()); &#125;) &#125; &#125;) $("#edit").alertWhileClick();&lt;/script&gt; $.extend Description: Merge the contents of two or more objects together into the first object.(大意是将两个或多个对象的内容合并到第一个对象中。) 示例:实例对象合并 123456let apple = &#123;color:"red",price:1.0,limit:2&#125;;let banana = &#123;color:&#123;color1:"yellow",color2:"green"&#125;,price:2.0&#125;;$.extend(apple,banana);$(function() &#123; $("#log").append(JSON.stringify(apple));&#125;) 资料参考: jQuery.fn.extend api jQuery.extend api]]></content>
      <categories>
        <category>技术</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[整合rabbitMQ]]></title>
    <url>%2Fposts%2F3b2e564b%2F</url>
    <content type="text"><![CDATA[docker启动rabbitMQ123456-- 安装rabbitMQ带后台管理界面(带management),推荐使用daocloud加速,速度特别快$ docker pull rabbitmq:management-alpine-- docker后台运行(5672:服务器与客户端交互端口,15672:web管理界面端口)$ docker run -d -p 5672:5672 -p 15672:15672 --name myrabbitmq IMAGE_ID-- 进入rabbitmq后台(name:guest;password:guest)127.0.0.1:15672 导入maven依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 项目Demo消息发送 RabbitProperties:封装了RabbitMQ的配置RabbitTemplate:给RabbitMQ发送和接收消息AmqpAdmin:RabbitMQ系统管理功能组建 1234567891011121314151617181920212223242526 @Autowired RabbitTemplate rabbitTemplate;/** * 1.单播模式(点对点):direct */ @Test public void contextLoads() &#123; //Message需要自己构造一个;定义消息体内容和消息头 //rabbitTemplate.send(exchange,routingKey,message); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("msg","hello world"); map.put("data", Arrays.asList("hi",1)); //对象被默认序列化后发送出去(广播模式可以陆由键为"") rabbitTemplate.convertAndSend("exchange.direct","atguigu.news",map); &#125; /** * 接收消息 */ @Test public void receive() &#123; //填写消息队列名称 Object obj = rabbitTemplate.receiveAndConvert("atguigu.news"); System.out.println(obj);//&#123;msg=hello world, data=[hi, 1]&#125; &#125; 默认序列化使用application/x-java-serialized-object 如何将消息转化为json? 123456789101112@Configurationpublic class MyAmqpConfig &#123; /** * 消息序列化为json * @return */ @Bean public MessageConverter messageConverter() &#123; return new Jackson2JsonMessageConverter(); &#125;&#125; rabbitmq发送对象 1234567891011121314151617 @Autowired RabbitTemplate rabbitTemplate;/** * 1.单播模式(点对点):direct */ @Test public void contextLoads() &#123; //Message需要自己构造一个;定义消息体内容和消息头 //rabbitTemplate.send(exchange,routingKey,message); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("msg","hello world"); map.put("data", Arrays.asList("hi",1)); //对象被默认序列化后发送出去 rabbitTemplate.convertAndSend("exchange.direct","atguigu.news",new Book("西游记","吴承恩")); &#125; 进行消息监听1234567891011/**消息监听启动需要在application启动类上添加@EnableRabbit注解*/@Servicepublic class BookService &#123; //监听队列 @RabbitListener(queues = "atguigu.news") public void receive(Book book) &#123; System.out.println("收到消息"+book); &#125;&#125; 创建交换器1234567891011121314151617@AutowiredAmqpAdmin amqpAdmin;/** * 创建交换器 */@Testpublic void createExchange() &#123; //创建交换器 amqpAdmin.declareExchange(new DirectExchange("lsj.direct")); //创建队列 amqpAdmin.declareQueue(new Queue("test.queue")); //创建绑定规则 amqpAdmin.declareBinding(new Binding("test.queue", Binding.DestinationType.QUEUE,"lsj.direct","hh",null)); System.out.println("创建完成");&#125;]]></content>
      <categories>
        <category>技术</category>
        <category>消息</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用git命令]]></title>
    <url>%2Fposts%2F335a5d78%2F</url>
    <content type="text"><![CDATA[绪论:因为经常用到git命令,常用命令时常记不住,所以在此处对常用git命令做个记录 新建代码库在当前目录新建一个git仓库1$ git init 新建一个目录并初始化为git仓库1$ git init [project-name] Clone project1$ git clone [url] 配置显示当前的git配置1$ git config --list 配置git提交的用户信息12$ git config [--global] user.name "name"$ git config [--global] user.email "email" 增加/删除文件添加指定文件到暂存区1$ git add [file1] [file2] ... 添加指定目录到暂存区1$ git add [dir] 添加当前目录的所有文件到暂存区1$ git add . 添加每个变化前都会要求确认/对于同一文件的多处变化可以实现分次提交1$ git add -p 删除工作分区文件,并将这次删除放入暂存区1$ git rm [file1] [file2] ... 停止追踪指定文件,但该文件会保留在工作区1$ git rm --cached [file] 改名文件,并将这个改名放入暂存区1$ git mv [file-origin] [file-renamed] 代码提交提交暂存区到仓库区1$ git commit -m [message] 提交暂存区的指定文件到仓库区1$ git commit [file1] [file2] ... -m [message] 提交工作区自上次commit后的变化,直接到仓库区1$ git commit -a 提交时显示所有diff信息1$ git commit -v 使用一次新的commit,替代上一次提交1$ git commit --amend -m [message] 重做上一次commit,并包括指定文件的新变化1$ git commmit -amend [file1] [file2] ... 分支列出所有本地分支1$ git branch 列出所有远程分支1$ git branch -r 列出所有本地分支和远程分支1$ git branch -a 新建一个分支,但仍然停留在当前分支1$ git branch [branch-name] 新建一个分支,并切换到该分支1$ git checkout -b [branch-name] 新建一个分支,指向指定commit1$ git branch [branch] [commit] 新建一个分支,与指定的远程分支建立追踪关系1$ git branch --track [branch] [remote-branch] 切换到指定分支,并更新工作区1$ git checkout [branch-name] 切换到上一个分支1$ git checkout - 建立追踪关系,在现有分支与指定的远程分支之间1$ git branch --set-upstream [branch] [remote-branch] 合并指定分支到当前分支1$ git merge [branch] 选择一个commit,合并进当前分支1$ git cherry-pick [commit] 删除分支1$ git branch -d [branch-name] 删除远程分支12$ git push prigin --delete [branch-name]$ git branch -dr [remote/branch] 标签列出所有tag1$ git tag 新建一个tag在当前commit1$ git tage [tag] 新建一个tag在指定commit1$ git tag [tag] [commit] 删除本地tag1$ git tag -d [tag] 删除远程tag1$ git push origin :refs/tags/[tagName] 查看tag信息1$ git show [tag] 提交指定tag1$ git push [remote] [tag] 提交所有tag1$ git push [remote] --tags 新建一个分支,指向某个tag1$ git checkout -b [branch] [tag] 查看信息查看有变更的文件1$ git status 显示当前分支的版本历史1$ git log 显示commit历史,以及每一次commit发生变更的文件1$ git log --stat 搜索提交历史,根据关键字1$ git log -S [keyword] 显示某个commit之后的所有变动,每个commit占据一行1$ git log [tag] HEAD --pretty=format:%s 显示某个commiy之后的所有变动,其提交说明必须符合搜索条件1$ git log [tag] HEAD --grep feature 显示某个文件的版本历史,包括文件改名12$ git log --follow [file]$ git whatchanged [file] 显示指定文件的每一次diff1$ git log -p [file] 显示过去5次提交1$ git log -5 --pretty --online 显示所有提交过的用户,按提交次数排序1$ git shortlog -sn 显示指定文件是什么人在什么时间修改过1$ git blame [file] 显示暂存区和工作区的差异1$ git diff 显示暂存区和上一次commit的差异1$ git diff --cached [file] 显示工作区与当前分支最新commit之间的差异1$ git diff [first-branch] ... [second-branch] 显示今天你写了多少行代码1$ git diff --shortstat "@&#123;0 day ago&#125;" 显示某次提交的元数据和内容变化1$ git show [commit] 显示某次提交发生变化的文件1$ git show --name-only [commit] 显示某次提交时,某个文件的内容1$ git show [commit]:[filename] 显示当前分支的最近几次提交1$ git reflog 远程同步下载远程仓库的所有变动1$ git fetch [remote] 显示所有远程仓库1$ git remote -v 显示某个远程仓库的信息1$ git remote show [remote] 增加一个新的远程仓库,并命名1$ git remote add [shortname] [url] 取回远程仓库的变化,并与本地分支合并1$ git pull [remote] [branch] 上传本地指定分支到远程仓库1$ git push [remote] [branch] 强行推送当前分支到远程仓库,即使有冲突1$ git push [remote] --force 推送所有分支到远程仓库1$ git push [remote] --all 撤销恢复暂存区的指定文件到工作区1$ git checkout [file] 恢复某个commit的指定文件到暂存区和工作区1$ git checkout [commit] [file] 恢复暂存区的所有文件到工作区1$ git checkout . 重置暂存区的指定文件,与上次commit保持一致,但工作区不变1$ git reset [file] 重置暂存区与工作区,与上一次commit保持一致1$ git reset --hard 重置当前分支的指针为指定commit,同时重置暂存区,但工作区不变1$ git reset [commit] 重置当前分支的HEAD为指定commit,同时重置暂存区和工作区,与指定commit一致1$ git reset --hard [commit] 重置当前HEAD为指定commit,但保持暂存区和工作区保持不变1$ git reset --keep [commit] 新建一个commit,用来撤销指定commit,后者的所有变化都将被前者抵消,并应用到当前分支1$ git revert [commit] 暂时将未提交的变化移出,稍后再移入12$ git stash$ git stash pop 其他生成可供发布的压缩包1$ git archive]]></content>
      <categories>
        <category>技术</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java实现生产者与消费者]]></title>
    <url>%2Fposts%2Fc0369f57%2F</url>
    <content type="text"><![CDATA[本文属于转载,因为发现挺重要,所以在此记录下 生产者和消费者问题是线程模型中的经典问题：生产者和消费者在同一时间段内共用同一个存储空间，生产者往存储空间中添加产品，消费者从存储空间中取走产品，当存储空间为空时，消费者阻塞，当存储空间满时，生产者阻塞。 wait()和notify()方法的实现 缓冲区满和为空时都调用wait()方法等待，当生产者生产了一个产品或者消费者消费了一个产品之后会唤醒所有线程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * 消费者/生产者 * @author 刘世杰 * @date 2019/8/11 */public class ThreadDemo &#123; private static Integer count = 0; private static final Integer Full = 10; private static String Lock = "lock"; public static void main(String[] args) &#123; ThreadDemo demo = new ThreadDemo(); new Thread(demo.new Producer()).start(); new Thread(demo.new Producer()).start(); new Thread(demo.new Consumer()).start(); &#125; class Producer implements Runnable&#123; @Override public void run() &#123; for(;;) &#123; try &#123; Thread.sleep(3000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; synchronized (Lock) &#123; while (count == Full) &#123; try &#123; Lock.wait(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; count++; System.out.println(Thread.currentThread().getName()+"生产者生产,目前总共有"+count); Lock.notifyAll(); &#125; &#125; &#125; &#125; class Consumer implements Runnable&#123; @Override public void run() &#123; for (;;) &#123; try &#123; Thread.sleep(3000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; synchronized (Lock) &#123; while (count == 0) &#123; try &#123; Lock.wait(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; count--; System.out.println(Thread.currentThread().getName()+"消费者消费,目前总共有"+count); Lock.notifyAll(); &#125; &#125; &#125; &#125;&#125; 结果: 12345678Thread-0生产者生产,目前总共有1Thread-3消费者消费,目前总共有0Thread-2生产者生产,目前总共有1Thread-1消费者消费,目前总共有0Thread-0生产者生产,目前总共有1Thread-3消费者消费,目前总共有0Thread-2生产者生产,目前总共有1Thread-1消费者消费,目前总共有0 可重入锁ReentrantLock的实现 java.util.concurrent.lock 中的 Lock 框架是锁定的一个抽象，通过对lock的lock()方法和unlock()方法实现了对锁的显示控制，而synchronize()则是对锁的隐性控制。可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响，简单来说，该锁维护这一个与获取锁相关的计数器，如果拥有锁的某个线程再次得到锁，那么获取计数器就加1，函数调用结束计数器就减1，然后锁需要被释放两次才能获得真正释放。已经获取锁的线程进入其他需要相同锁的同步代码块不会被阻塞。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * 可重用锁实现生产者/消费者 * @author 刘世杰 * @date 2019/8/11 */public class ThreadDemo02 &#123; private static Integer count = 0; private static final Integer FULL = 10; //创建一个锁对象 private Lock lock = new ReentrantLock(); //创建两个条件变量,一个为缓冲区未满,一个为缓冲区非空 private final Condition notFull = lock.newCondition(); private final Condition notEmpty = lock.newCondition(); public static void main(String[] args) &#123; ThreadDemo02 demo02 = new ThreadDemo02(); new Thread(demo02.new Producer()).start(); new Thread(demo02.new Consumer()).start(); new Thread(demo02.new Producer()).start(); new Thread(demo02.new Consumer()).start(); &#125; class Producer implements Runnable &#123; @Override public void run() &#123; for (;;) &#123; try &#123; Thread.sleep(3000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //获取锁 lock.lock(); try &#123; while(count == FULL) &#123; try &#123; notFull.await(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; count++; System.out.println(Thread.currentThread().getName()+"生产者生产,当前总共"+count); //唤醒消费者 notEmpty.signal(); &#125; finally &#123; //释放锁 lock.unlock(); &#125; &#125; &#125; &#125; class Consumer implements Runnable &#123; @Override public void run() &#123; for(;;) &#123; try &#123; Thread.sleep(3000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //获取锁 lock.lock(); try &#123; while(count == 0) &#123; try &#123; notEmpty.await(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; count--; System.out.println(Thread.currentThread().getName()+"消费者消费,当前总共"+count); //唤醒生产者 notFull.signal(); &#125; finally &#123; //释放锁 lock.unlock(); &#125; &#125; &#125; &#125;&#125; 阻塞队列BlockingQueue的实现BlockingQueue即阻塞队列，从阻塞这个词可以看出，在某些情况下对阻塞队列的访问可能会造成阻塞。被阻塞的情况主要有如下两种: 当队列满了的时候进行入队列操作 当队列空了的时候进行出队列操作因此，当一个线程对已经满了的阻塞队列进行入队操作时会阻塞，除非有另外一个线程进行了出队操作，当一个线程对一个空的阻塞队列进行出队操作时也会阻塞，除非有另外一个线程进行了入队操作。从上可知，阻塞队列是线程安全的。下面是BlockingQueue接口的一些方法: 操作 抛异常 特定值 阻塞 超时 插入 add(o) offer(o) put(o) offer(o, timeout, timeunit) 移除 remove(o) poll(o) take(o) poll(timeout, timeunit) 检查 element(o) peek(o) 这四类方法分别对应的是：1 . ThrowsException：如果操作不能马上进行，则抛出异常2 . SpecialValue：如果操作不能马上进行，将会返回一个特殊的值，一般是true或者false3 . Blocks:如果操作不能马上进行，操作会被阻塞4 . TimesOut:如果操作不能马上进行，操作会被阻塞指定的时间，如果指定时间没执行，则返回一个特殊值，一般是true或者false下面来看由阻塞队列实现的生产者消费者模型,这里我们使用take()和put()方法，这里生产者和生产者，消费者和消费者之间不存在同步，所以会出现连续生成和连续消费的现象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.BlockingQueue;/** * BlockingQueue实现生产者/消费者 * @author 刘世杰 * @date 2019/8/11 */public class ThreadDemo03 &#123; private static Integer count = 0; //创建一个阻塞队列 final BlockingQueue blockingQueue = new ArrayBlockingQueue&lt;&gt;(10); public static void main(String[] args) &#123; ThreadDemo03 demo03 = new ThreadDemo03(); new Thread(demo03.new Producer()).start(); new Thread(demo03.new Consumer()).start(); &#125; class Producer implements Runnable &#123; @Override public void run() &#123; for (;;) &#123; try &#123; Thread.sleep(3000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; try &#123; blockingQueue.put(1); count++; System.out.println(Thread.currentThread().getName() + "生产者生产，目前总共有" + count); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; class Consumer implements Runnable &#123; @Override public void run() &#123; for(;;) &#123; try &#123; Thread.sleep(3000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; try &#123; blockingQueue.take(); count--; System.out.println(Thread.currentThread().getName() + "消费者消费，目前总共有" + count); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 信号量Semaphore的实现 Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源，在操作系统中是一个非常重要的问题，可以用来解决哲学家就餐问题。Java中的Semaphore维护了一个许可集，一开始先设定这个许可集的数量，可以使用acquire()方法获得一个许可，当许可不足时会被阻塞，release()添加一个许可。在下列代码中，还加入了另外一个mutex信号量，维护生产者消费者之间的同步关系，保证生产者和消费者之间的交替进行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.util.concurrent.Semaphore;/** * Semaphore实现生产者/消费者 * @author 刘世杰 * @date 2019/8/11 */public class ThreadDemo04 &#123; private static Integer count = 0; //创建三个信号变量 final Semaphore notFull = new Semaphore(10); final Semaphore notEmpty = new Semaphore(0); final Semaphore mutex = new Semaphore(1); public static void main(String[] args) &#123; ThreadDemo04 demo04 = new ThreadDemo04(); new Thread(demo04.new Producer()).start(); new Thread(demo04.new Consumer()).start(); &#125; class Producer implements Runnable &#123; @Override public void run() &#123; for (;;) &#123; try &#123; Thread.sleep(3000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; try &#123; notFull.acquire(); mutex.acquire(); count++; System.out.println(Thread.currentThread().getName() + "生产者生产，目前总共有" + count); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; mutex.release(); notEmpty.release(); &#125; &#125; &#125; &#125; class Consumer implements Runnable &#123; @Override public void run() &#123; for (;;) &#123; try &#123; Thread.sleep(3000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; try &#123; notEmpty.acquire(); mutex.acquire(); count--; System.out.println(Thread.currentThread().getName() + "消费者消费，目前总共有" + count); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; mutex.release(); notFull.release(); &#125; &#125; &#125; &#125;&#125; 管道输入输出流PipedInputStream和PipedOutputStream实现 在java的io包下，PipedOutputStream和PipedInputStream分别是管道输出流和管道输入流。它们的作用是让多线程可以通过管道进行线程间的通讯。在使用管道通信时，必须将PipedOutputStream和PipedInputStream配套使用。使用方法：先创建一个管道输入流和管道输出流，然后将输入流和输出流进行连接，用生产者线程往管道输出流中写入数据，消费者在管道输入流中读取数据，这样就可以实现了不同线程间的相互通讯，但是这种方式在生产者和生产者、消费者和消费者之间不能保证同步，也就是说在一个生产者和一个消费者的情况下是可以生产者和消费者之间交替运行的，多个生成者和多个消费者者之间则不行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import java.io.IOException;import java.io.PipedInputStream;import java.io.PipedOutputStream;/** * 使用管道实现生产者/消费者 * @author 刘世杰 * @date 2019/8/11 */public class ThreadDemo05 &#123; final PipedInputStream pis = new PipedInputStream(); final PipedOutputStream pos = new PipedOutputStream(); &#123; try &#123; pis.connect(pos); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; ThreadDemo05 demo05 = new ThreadDemo05(); new Thread(demo05.new Producer()).start(); new Thread(demo05.new Consumer()).start(); new Thread(demo05.new Consumer()).start(); &#125; class Producer implements Runnable &#123; @Override public void run() &#123; try &#123; while(true) &#123; Thread.sleep(3000); int num = (int)(Math.random() * 255); System.out.println(Thread.currentThread().getName() + "生产者生产了一个数字，该数字为： " + num); pos.write(num); pos.flush(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; pos.close(); pis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; class Consumer implements Runnable &#123; @Override public void run() &#123; try &#123; while(true) &#123; Thread.sleep(3000); int num = pis.read(); System.out.println("消费者消费了一个数字，该数字为：" + num); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; pos.close(); pis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 1234567891011121314151617181920Thread-0生产者生产了一个数字，该数字为： 118消费者消费了一个数字，该数字为：118Thread-0生产者生产了一个数字，该数字为： 94消费者消费了一个数字，该数字为：94Thread-0生产者生产了一个数字，该数字为： 107消费者消费了一个数字，该数字为：107Thread-0生产者生产了一个数字，该数字为： 140消费者消费了一个数字，该数字为：140Thread-0生产者生产了一个数字，该数字为： 225消费者消费了一个数字，该数字为：225Thread-0生产者生产了一个数字，该数字为： 66消费者消费了一个数字，该数字为：66Thread-0生产者生产了一个数字，该数字为： 154消费者消费了一个数字，该数字为：154Thread-0生产者生产了一个数字，该数字为： 69消费者消费了一个数字，该数字为：69Thread-0生产者生产了一个数字，该数字为： 226消费者消费了一个数字，该数字为：226Thread-0生产者生产了一个数字，该数字为： 178消费者消费了一个数字，该数字为：178 资料来源: java实现生产者消费者]]></content>
      <categories>
        <category>技术</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用docker实现nginx反向代理]]></title>
    <url>%2Fposts%2F92d34c63%2F</url>
    <content type="text"><![CDATA[本文使用技术栈:dokcer,nginx,ubuntu18.04,openssl docker运行nginx docker pull 1docker pull nginx docker查看镜像库 1docker images docker后台运行 1docker container run -d -p 127.0.0.2:8080:80 --name nginx-proxy nginx -d：在后台运行 -p ：容器的80端口映射到127.0.0.2:8080 --rm：容器停止运行后，自动删除容器文件 --name：容器的名字为mynginx 映射网页目录 网页都在容器内不便于修改,所以需要网页目录映射本地 123456789101112131415161718$ mkdir nginx-docker-demo$ cd nginx-docker-demo## 该目录下新建index.html$ echo &gt;&gt; index.html## 需要停止原有容器-此次127.0.0.2:8080就可以看见index.html内容了$ docker container run \ -d \ -p 127.0.0.2:8080:80 \ --rm \ --name mynginx \ --volume "$PWD/html":/usr/share/nginx/html \ nginx## 容器停止$ docker container stop mynginx 拷贝配置12345678## 此时本地会多出一个nginx子目录$ docker container cp mynginx:/etc/nginx .## 子目录更名为confmv nginx conf## 此时就可以关闭nginx了$ docker container stop mynginx 映射配置目录1234567891011## 重新启动新的容器docker container run \ --rm \ --name mynginx \ --volume "$PWD/html":/usr/share/nginx/html \ --volume "$PWD/conf":/etc/nginx \ -p 127.0.0.2:8080:80 \ -d \ nginx ## 访问127.0.0.2:8080 如果成功则配置完成 自签名证书–此处通过openssl openssl安装 12sudo apt-get install opensslsudo apt-get install libssl-dev 进行自签名 1234567$ sudo openssl req \ -x509 \ -nodes \ -days 365 \ -newkey rsa:2048 \ -keyout example.key \ -out example.crt 如上参数说明： req：处理证书签署请求。 -x509：生成自签名证书。 -nodes：跳过为证书设置密码的阶段，这样 Nginx 才可以直接打开证书。 -days 365：证书有效期为一年。 -newkey rsa:2048：生成一个新的私钥，采用的算法是2048位的 RSA。 -keyout：新生成的私钥文件为当前目录下的example.key。 -out：新生成的证书文件为当前目录下的example.crt。 自签名后会要求填写一些信息,正式证书需要CA签名 12## 最重要的一条信息Common Name (e.g. server FQDN or YOUR name) []:127.0.0.2 回答完问题后当前目录下会多出两个文件:example.key和example.crt 123## conf目录下新建certs目录--将文件放入cert目录$ mkdir conf/certs$ mv example.crt example.key conf/certs 有了密钥和证书就可以打开nginx的https了 打开如下文件: conf/conf.d/default.conf 123456789101112131415161718192021## 将server放入最后server &#123; ## 443端可以是https的专用端口 listen 443 ssl http2; server_name localhost; ssl on; ssl_certificate /etc/nginx/certs/example.crt; ssl_certificate_key /etc/nginx/certs/example.key; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / &#123; root /usr/share/nginx/html; index index.html index.htm; &#125;&#125; 重新启动nginx容器 12345678910## 注意:$PWD表示当前路径-小心不要入坑$ docker container run \ --rm \ --name mynginx \ --volume "$PWD/html":/usr/share/nginx/html \ --volume "$PWD/conf":/etc/nginx \ -p 127.0.0.2:8080:80 \ -p 127.0.0.2:8081:443 \ -d \ nginx 此时就可以通过127.0.0.2:8080和127.0.0.2:8081进行访问可以看见html内容,因为是自签名所以会报不安全 资料参考:nginx容器教程-阮一峰]]></content>
      <categories>
        <category>技术</category>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vps建站]]></title>
    <url>%2Fposts%2F2fbc60fa%2F</url>
    <content type="text"><![CDATA[工具使用–很多地方需要翻墙,如果不能可寻求替代方案 vps - vultr(搭建服务器) namesilo(域名注册) 宝塔linux ubuntu18.04 wordpress(博客框架-也可以放入自己的代码) vultrvultr官网 vultr的另一类用途不解释-社会主义 [vultr注册充值]-网上很多教程vultr创建服务器 点击deploy new server 选择server-location(推荐日本节点) 选择server-type(我的是ubuntu18.04) 选择server-size,如果只是小型网站,可以选择$5/月 然后选择Deploy Now 然后进入products,等待一会儿服务器status变为running即可-可以通过ping测试 7.点击进入-查看相关信息 namesilonamesilo官网 购买域名 直接搜索namesilo域名购买与使用教程,网上很多资料 域名解析(重要)manage my domains-&gt;进入如下界面点击如下按钮 点击后会进入如下页面 说明:此处的ipv4 address使用前面vps查看相关信息的ip,因为namesilo域名解析速度有点儿慢,所以最多可能要等几个小时,可以通过ping renoblog.xyz来测试(不能ping通就继续等),直到能ping通为止 宝塔linux宝塔linux官网 ubuntu一键安装脚本,其他系统也可以在里面找到 wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh &amp;&amp; sudo bash install.sh 如下是vps的详细信息,待会儿会用到 然后进入linux终端(需要sudo) 123ssh root@198.13.35.151## 接下来会提示输入密码(直接复制粘贴即可,密码是隐藏的)## 稍微等会儿,将刚才的一键安装脚本粘贴进入,然后等待运行 然后等待安装后能看到url,user,password-因为已经安装过了,所以我只能查找下,可能与第一次安装有所区别,但是没影响 密码找回,如果不小心关了终端,可以ssh进入然后bt default命令 查询url网址,然后输入user,password,会进入如下页面-如果出现运行环境不对,可以在软件商店更换运行环境 安装完成后,点击网站-&gt;添加网站 域名填写自己的域名即可,如果是静态网站可以选择不安装 进入网站-&gt;根目录,进入如下页面,我使用的wordpress,网站目录就不介绍了,我直接使用的wordpress,导入wordpress并解析所有文件且放入根目录即可通过域名进入 其他安全设置,监控,ftp自行查询 wordpresswordpress下载 下载wordpress模板,如果是自己的网站模板也可以 然后输入域名就可以进入wordpress后台了,接下来的操作都很简单,就不一一介绍了]]></content>
      <categories>
        <category>技术</category>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>site</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO详解]]></title>
    <url>%2Fposts%2F88bb8d2a%2F</url>
    <content type="text"><![CDATA[概览Java的io大概可以分为以下分类 磁盘操作：File 字节操作:Inputstream和OutputStream 字符操作:Reader和Writer 对象操作:Serializable 网络操作:Scoket 新的输入和输出:NIO 磁盘操作File类可以用于表示文件的目录和信息,不表示文件的内容 123456789101112131415/*** 递归获取目录下所有文件*/void diskOperate(File file) &#123; if(file == null || !file.exists()) &#123; return; &#125; if(file.isFile()) &#123; System.out.println(file.getName()); return; &#125; for (File fi : file.listFiles()) &#123; diskOperate(fi); &#125;&#125; 字节操作1234567891011121314151617/** * 字节实现文件复制- * 此处省略了未进行详细文件类型以及文件是否存在判断 * @param src * @param dist */void copyFile(String src,String dist) throws IOException &#123; FileInputStream in = new FileInputStream(src); FileOutputStream out = new FileOutputStream(dist); byte[] buffer = new byte[20*1024]; int cnt; while((cnt = in.read(buffer,0,buffer.length)) != -1) &#123; out.write(buffer,0,cnt); &#125; in.close(); out.close();&#125; BufferedInputStream为FileInputStream提供缓存功能(装饰者模式)1BufferedInputStream in = new BufferedInputStream(new FileInputStream(file)); 字符操作编码就是将字符转为字节,解码就是将字节转为字符如果编码和解码过程中采用了不同的编码方式就会出现乱码 GBK:中文字符占2个字节,英文字符占1个字符 UTF-8：中文字符占3个字节,英文字符占1个字节 UTF-16be:中文和英文字符占2个字节1234String str1 = "中文";//getBytes的默认编码方式与平台有关byte[] bytes = str1.getBytes("UTF-8");String str2 = new String(bytes,"UTF-8");//中文 Read与Writter InputStreamReader: 实现从字节流解码为字符流 OutputStream:实现字符流解码为字节流12345678910111213/*** 逐行输出文本文件内容* @throws IOException*/void progressivePrint(String path) throws IOException&#123; FileReader reader = new FileReader(path); BufferedReader bufferedReader = new BufferedReader(reader); String line; while((line = bufferedReader.readLine()) != null) &#123; System.out.println(line); &#125; bufferedReader.close();&#125; 对象操作序列化:就是将一个对象转为字节序列,方便存储和传输(–便于网络传输等,比如在windows上序列化对象,可以在unix上完整还原,无视平台差异) 序列化:ObjectOutputStream.writeObject() 反序列化:ObjectInputStream.readObject() 不会对静态变量进行序列化,因为静态变量属于类的状态,序列化只是保存对象的状态 序列化的类需要实现Serializzable接口(标准-没有方法实现),但是不实现会抛出异常 使用transient可以避免属性被序列化 1private transient Object[] elementData; 对序列化感兴趣的可以查阅资料,此处不进行详细描述 网络操作java中的网络支持 InetAddress:用于表示网络上的硬件资源,即ip地址 URL：统一资源定位符 Sockets:使用tcp协议实现网络通信 Datagram:使用UDP协议实现网络通信InetAddress没有公有的构造函数,只能通过静态方法来创建实例InetAddress.getByName(String host);InetAddress.getByAddress(byte[] address); URL123456789101112131415161718/** * 直接从URL中获取字节流数据 */void netOperate() throws MalformedURLException,IOException &#123; URL url = new URL("https://www.baidu.com"); /* 字节流 */ InputStream in = url.openStream(); /* 字符流 */ InputStreamReader reader = new InputStreamReader(in,"utf-8"); /* 提供缓存功能 */ BufferedReader bufferedReader = new BufferedReader(reader); String line; while((line = bufferedReader.readLine()) != null) &#123; System.out.println(line); &#125; bufferedReader.close();&#125; Sockets ServerSocket:服务器端类 Socket:客户端类 服务器端和客户端通过InputStream和OutputStream进行输入输出Datagram DatagramSocket:通信类 DatagramPacket:数据包类NIOI/O与NIO最大的区别就是数据打包和传输的方式，I/O以流的方式处理数据,NIO以块的方式处理数据,弥补了I/O的不足,提供了高速的,面向块的IO NIO内容过多,此处不进行详细讲解 资料来源: CS-Notes]]></content>
      <categories>
        <category>技术</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>io</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot实战-cache]]></title>
    <url>%2Fposts%2Fc266cc15%2F</url>
    <content type="text"><![CDATA[文件配置 在日常的开发中,相信很多人都知道内存的速度要快于硬盘,而开发中瓶颈主要在数据库,所以需要相同的数据时，重复查询数据库会降低系统的性能,耗费大量的时间在数据库查询与方法调用上。 开发工具:idea jdK:1.8 开发环境:web环境 注释:本次测试使用jpa+mysql+lombok 引入所需依赖(*)： 123456789101112131415161718192021222324252627&lt;!-- cache 依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- jpa --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- web 启动类 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- mysql 数据库连接类 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- lombok --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; yml配置(properties内容一致,只是写法区别) spring.jpa.hibernate.ddl-auto: create:每次程序跑的时候，都会创建一个空的表。如果数据库中已经有这个表的话，会先删掉 update:第一次运行的时候，也会创建对应的数据表。但如果表里有数据，是不会删表，而是会保留 create-drop：应用停下来的时候，会把表删掉 validate：会验证实体类中的属性跟表结构是否一致，如果不一致的话会报错 none：默认的，什么都不做 123456789101112131415spring: ## 数据源 datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/student username: root password: 123 ## JPA jpa: hibernate: # ddl-auto: 设为 create 表示每次都重新建表 ddl-auto: update # 显示sql show-sql: true 继承接口JpaRepository-范型 12345678910package com.lsj.cache.dao;import com.lsj.cache.entity.Student;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.stereotype.Repository;@Repositorypublic interface StudentRepository extends JpaRepository&lt;Student, Integer&gt; &#123;&#125; entity –JPA用法此处不做详细描述 123456789101112131415161718192021222324package com.lsj.cache.entity;import lombok.AllArgsConstructor;import lombok.Getter;import lombok.NoArgsConstructor;import lombok.Setter;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;@Getter@Setter@AllArgsConstructor@NoArgsConstructor@Entity //声明为实体--可以指定tablepublic class Student &#123; @Id @GeneratedValue private Integer id; private String name; private Integer age;&#125; service 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.lsj.cache.service;import com.lsj.cache.dao.StudentRepository;import com.lsj.cache.entity.Student;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cache.annotation.CacheEvict;import org.springframework.cache.annotation.CachePut;import org.springframework.cache.annotation.Cacheable;import org.springframework.cache.annotation.EnableCaching;import org.springframework.stereotype.Service;@EnableCaching //开启缓存功能--也可以在启动类上开启@Servicepublic class StudentService &#123; //slf4j作为日志框架 private static final Logger LOGGER = LoggerFactory.getLogger(StudentService.class); @Autowired private StudentRepository studentRepository; //@CachePut 缓存新增的或更新的数据到缓存，其中缓存名称为 student 数据的 key 是 student 的 id @CachePut(value = "student",key = "#student.id") public Student saveStudent(Student student) &#123; Student stu = studentRepository.save(student); LOGGER.info("新增数据缓存到内存中"+student.getId()); return stu; &#125; @Cacheable(value = "student",key = "#id") public Student getStudentById(Integer id) &#123; Student stu = studentRepository.findById(id).get(); LOGGER.info("查询数据"+id); return stu; &#125; @CacheEvict(value="student") public void deleteStudentById(Integer id) &#123; studentRepository.deleteById(id); LOGGER.info("删除数据"+id); &#125;&#125; controller– 此处为了测试方便,统一使用的get请求,未遵循restful api风格 1234567891011121314151617181920212223242526272829303132333435package com.lsj.cache.controller;import com.lsj.cache.entity.Student;import com.lsj.cache.service.StudentService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping("/stu")public class StudentController &#123; @Autowired private StudentService studentService; //http://localhost:8080/stu/save?name=zs&amp;age=20 @GetMapping("/save") public Student saveStudent(Student stu) &#123; return studentService.saveStudent(stu); &#125; //http://localhost:8080/stu/able/1 @GetMapping("/able/&#123;id&#125;") public Student getStudentById(@PathVariable("id") Integer id) &#123; return studentService.getStudentById(id); &#125; //http://localhost:8080/stu/evict/1 @GetMapping("/evict/&#123;id&#125;") public void deleteStudentById(@PathVariable("id") Integer id) &#123; studentService.deleteStudentById(id); &#125;&#125; 缓存技术切换 EhCache: 12345&lt;!-- EhCache 依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache&lt;/artifactId&gt;&lt;/dependency&gt; Ehcache 所需配置文件 ehcache.xml 只需放在类路径（resource 目录）下，SpringBoot 会自动扫描，如： 1234&lt;?xml version="1.0" encoding="UTF-8"&gt;&lt;ehcache&gt; &lt;cache name="student" maxElementsInMmory="1000"&gt;&lt;ehcache&gt; SpringBoot 会自动配置 EhcacheManager 的 Bean 切换 Guava 123456&lt;!-- GuavaCache 依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;18.0&lt;/version&gt;&lt;/dependency&gt; 切换 RedisCache 12345&lt;!-- cache 依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt;&lt;/dependency&gt; 理论相关 spring支持的cacheManager CacheManager 描述 SimpleCacheManager 使用简单的 Collection 来存储缓存，主要用于测试 ConcurrentMapCacheManager 使用 ConcurrentMap 来存储缓存 NoOpCacheManager 仅测试用途，不会实际缓存数据 EhCacheCacheManager 使用 EhCache 作为缓存技术 GuavaCacheManager 使用 Google Guava 的 GuavaCache 作为缓存技术 HazelcastCacheManager 使用 Hazelcast 作为缓存技术 JCacheCacheManager 支持 JCache(JSR-107) 标准的实现作为缓存技术，如 ApacheCommonsJCS RedisCacheManager 使用 Redis 作为缓存技术 在使用以上任意一个实现的 CacheManager 的时候，需注册实现的 CacheManager 的 Bean，如： 12345@Beanpublic EhCacheCacheManager cacheManager(CacheManager ehCacheCacheManager)&#123; return new EhCacheCacheManager(ehCacheCacheManager);&#125; 缓存注解 注解 解释 @Cacheable 在方法执行前 Spring 先查看缓存中是否有数据，若有，则直接返回缓存数据；若无数据，调用方法将方法返回值放入缓存中 @CachePut 无论怎样，都会将方法的返回值放到缓存中。 @CacheEvict 将一条或多条数据从缓存中删除 @Caching 可以通过 @Caching 注解组合多个注解策略在一个方法上 @Cacheable、@CachePut、@CacheEvict 都有 value 属性，指定的是要使用的缓存名称；key 属性指定的是数据在缓存中存储的键。 开启声明式缓存支持 12345@Configuration@EnableCaching //开启缓存支持public class AppConfig&#123;&#125; SpringBoot 的支持 在 Spring 中使用缓存技术的关键是配置 CacheManager ，而 SpringBoot 为我们配置了多个 CacheManager 的实现。 它的自动配置放在 org.springframework.boot.autoconfigure.cache 包中。 在不做任何配置的情况下，默认使用的是 SimpleCacheConfiguration ，即使用 ConcurrentMapCacheManager。SpringBoot 支持以前缀来配置缓存。例如： 1234567spring.cache.type= # 可选 generic、ehcache、hazelcast、infinispan、jcache、redis、guava、simple、nonespring.cache.cache-names= # 程序启动时创建的缓存名称spring.cache.ehcache.config= # ehcache 配置文件的地址spring.cache.hazelcast.config= # hazelcast配置文件的地址spring.cache.infinispan.config= # infinispan配置文件的地址spring.cache.jcache.config= # jcache配置文件的地址spring.cache.jcache.provider= # 当多个 jcache 实现在类路径的时候，指定 jcache 实现]]></content>
      <categories>
        <category>技术</category>
        <category>Spring-Boot</category>
      </categories>
      <tags>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker上手]]></title>
    <url>%2Fposts%2F8675a597%2F</url>
    <content type="text"><![CDATA[docker安装资料参考： 安装环境-ubuntu 18.04(终端) 1.sudo apt install docker.io 2.sudo systemctl start docker 3.sudo systemctl enable docker 查看docker是否安装完成 docker -v docker使用 例：docker search mysql –实际相当于在https://hub.docker.com/进行查询 docker下载库(加name即可) docker pull mysql – 默认下载latest版本 docker换源 1.修改json文件：vi /etc/docker/daemon.json-加入如下代码{ “registry-mirrors” : [“https://docker.mirrors.ustc.edu.cn&quot;]}2.重启服务sudo service docker restart||如果出现以下问题,可通过重启服务解决Error response from daemon: Get https://registry-1.docker.io/v2/: dial tcp: lookup registry-1.docker.io: no such host 查看docker镜像 docker images 下载指定版本镜像(版本可以在网站查找) docker pull mysql:5.5 镜像删除 docker rmi image-id 容器安装软件镜像(qq安装程序)-运行镜像-产生一个新容器(正在运行的软件) 步骤： 1.搜索镜像 docker search tomcat 2.拉取镜像 docker pull tomcat 3.根据镜像启动容器 docker run –name container-name -d image-name 如:docker run –mytomcat -d tomcat –name:自定义容器名 -d:后台运行 image-name:指定镜像模板 4.查看运行中的容器 docker ps 5.docker停止 docker stop container_id 6.查看所有的容器 docker ps -a 7.删除容器（rmi是删除镜像,rm是删除容器） docker rm contaner_id 8.端口映射(-p) -8888映射8080— 需要关闭防火墙服务 docker run -d -p 8888:8080 tomcat 9.查看防火墙状态 sudo ufw status 10.容器日志 docker logs container-name/container-id 更多命令查看: https://docs.docker.com/engine/reference/commandline/docker docker安装mysql 具体操作参考dockerhub 1.docker pull mysql 2.$ docker run –name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag]]></content>
      <categories>
        <category>技术</category>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hugo博客搭建]]></title>
    <url>%2Fposts%2Fccb0aaa5%2F</url>
    <content type="text"><![CDATA[hugo官方资料参考 终端（使用linux终端-ubuntu18.04） 安装hugo(macos使用brew) –因为apt-get下载版本太低,所以使用snap 1snap install hugo 检查hugo版本 1hugo version 创建博客 1hugo new site hugoblog 切换到blog目录 1cd hugoblog hugo主题下载:hugo主题 示例: 12$ cd [path] //切换到hugo博客根目录$ git clone https://github.com/vaga/hugo-theme-m10c.git themes/m10c //主题会存放在themes目录下 启动服务 1hugo server -t m10c --buildDrafts //指定m10c主题 创建文章(md) 1hugo new post/hugo搭建.md //创建后再次启动服务即可 github部署 创建github仓库 1取名为:helloworld-liushijie.github.io 将个人博客部署到远端服务器 basic1hugo --theme=m10c --baseUrl=&quot;https://helloworld-liushijie.github.io/&quot; --buildDrafts 部署成功后会生成public文件夹,切换到public文件夹,将public文件夹传到github basic12345$ git init$ git add . //全部加入$ git commit -m &quot;hugo blog commit&quot;$ git remote add origin https://github.com/helloworld-liushijie/helloworld-liushijie.github.io.git$ git push -u origin master //推到远端(输入username pwd)]]></content>
      <categories>
        <category>技术</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hugo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[var,let,const关键字]]></title>
    <url>%2Fposts%2F2c19b075%2F</url>
    <content type="text"><![CDATA[相信知道es6的大家都或多或少的知道es6中新增了let,const关键字用于声明标识符,那么他们之间具体有什么区别呢? let声明变量,会在当前作用域形成代码块 const用于声明常量,所谓常量就是物理指针不可以更改的变量1234567891011//let,const只在块级作用域有效&#123; let i = 10;&#125;console.log(i);//报错: i is not defined//var定义的变量，没有块的概念，可以跨块访问，不能跨函数访问&#123; var i = 10;&#125;console.log(i);//10 var var声明的变量会存在变量提升1234567console.log(a);//undefinedvar a = 10;实际等同于：var a;console.log(a);a = 10; 所以在使用时，注意先进行变量声明 1234567891011var x = 1;if (x === 1) &#123; var x = 2; console.log(x); // expected output: 2&#125;console.log(x);// expected output: 2 More info: var let接下来介绍下 let 的特性，使用 let 声明的变量，只能在当前代码块中访问和使用，有些类似于函数作用域，但是它又有几点不同的地方 let 声明变量，变量不会被提升。 12345function fn1()&#123; console.log(a); let a = 1;&#125;fn1(); // 报错 for 循环中 使用let 定义变量，只在for的循环周期内可以使用 12345678910111213for(var i = 0;i &lt; 5;i++) &#123; setTimeout(function() &#123; console.log(i) &#125;, 1000);&#125;//结果：5个5for(let i = 0;i &lt; 5;i++) &#123; setTimeout(function() &#123; console.log(i) &#125;, 1000);&#125;//结果：0，1，2，3，4 constconst除了不能改变物理指针的特性外,其他特性和let一样 使用const必须初始化 12345let i;console.log(i);//undefinedconst i;console.log(i);// Missing initializer in const declaration 当声明复杂数据类型的时候，物理指针不可以改变，但是可以改变数据内的属性值，以及可以给数据添加新属性等操作。 12345const person = &#123; name:'mary'&#125;person.name = "jack";console.log(person);//'&#123;name:'jack'&#125;']]></content>
      <categories>
        <category>技术</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
</search>
